/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package voluspa

import (
	"bytes"
	"fmt"
	"strings"
)

const (
	// DefaultGroup is the default group name
	DefaultGroup = "all"

	DefaultRole = "default"

	remapPrefixBuffer  = "    "
	remapMaxLineLength = 100

	// generatedFileBanner is the text prepended to all config files
	generatedFileBanner = "# Code generated by Voluspa. DO NOT EDIT.\n\n"
)

// NOTE CustomerConfig and PropertyConfig are closely related.
// Every time I think I want to embed one in the other (or share a common struct),
// I'm reminded that the YAML parser does not handle embedded structs.

type CustomerConfig struct {
	owner         string
	reference     string
	lifecycle     LifecycleState
	property      string
	role          string
	filename      string
	sslCertNames  []string
	qps           int
	parentChild   bool
	parentDomains []string
	schemes       []string
	cdn           map[string]interface{}
	Remaps        []Remap
	HAProxyVIPs   []HAProxyVIP
}

type Remap struct {
	OriginURL       string
	IncomingURL     string
	Group           string
	Role            string
	scheme          string
	RegexMap        bool
	ConfigLocation  ConfigLocation
	mappingRules    []mappingRule
	sourceConfig    *ConfigEnvironment
	parentOverrides []ParentOverride
	parentDomain    string
}

// newCustomerConfig creates a new CustomerConfig from a PropertyConfig
func newCustomerConfig(p *PropertyConfig) (*CustomerConfig, error) {
	cc := &CustomerConfig{
		property:     p.Property,
		sslCertNames: p.SSLCertNames,
		parentChild:  p.ParentChild,
		lifecycle:    p.Lifecycle,
		qps:          p.QPS,
		owner:        p.Owner,
		reference:    p.Reference,
		role:         p.Role,
		cdn:          make(map[string]interface{}),
		schemes:      p.Schemes,
		HAProxyVIPs:  p.HAProxyVIPs,
	}
	for _, cdn := range p.CDN {
		cc.cdn[cdn] = nil
	}
	return cc, nil
}

func (c Remap) hasContent() bool {
	hasContent := false
	for i := range c.mappingRules {
		adapter := c.mappingRules[i]

		if adapter.hasContent() {
			hasContent = true
		}
	}
	return hasContent
}

func splitLine(value, prefix string) string {
	if len(value) < remapMaxLineLength {
		return value
	}

	if strings.Contains(value, "{%") {
		return value
	}

	words := strings.Split(value, " ")
	if len(words) < 2 {
		return value
	}

	out := bytes.Buffer{}
	out.WriteString(fmt.Sprintf("%s %s", words[0], words[1]))

	for i := 2; i < len(words); i++ {
		if words[i-1] == "@pparam=--config" {
			out.WriteString(fmt.Sprintf(" %s", words[i]))
			continue
		}
		out.WriteString(fmt.Sprintf(" \\\n%s  %s", prefix, words[i]))
	}
	return out.String()

}

func (c Remap) asRemapConf() string {
	var buf bytes.Buffer
	if c.RegexMap {
		buf.WriteString(fmt.Sprintf("regex_map"))
	} else {
		buf.WriteString(fmt.Sprintf("map"))
	}
	buf.WriteString(fmt.Sprintf(" %s \\\n    %s", c.IncomingURL, c.OriginURL))

	if !c.hasContent() {
		buf.WriteString("\n")
		return buf.String()
	}

	buf.WriteString(" \\\n")

	for i := range c.mappingRules {
		adapter := c.mappingRules[i]

		if !adapter.hasContent() {
			continue
		}

		prefixBuffer := remapPrefixBuffer
		content := adapter.ConfigContent.String()
		if adapter.isCommandLineTemplated() && strings.HasPrefix(content, "{%") {
			prefixBuffer = ""
		}

		buf.WriteString(fmt.Sprintf("%s%s", prefixBuffer, splitLine(content, prefixBuffer)))
		if adapter.isCommandLineTemplated() {
			continue
		}

		if i < len(c.mappingRules)-1 && c.mappingRules[i+1].hasContent() {
			buf.WriteString(" \\")
		}
		buf.WriteString("\n")
	}

	return buf.String()
}

func (c *CustomerConfig) remapConfigFilename(group string, configLocation ConfigLocation) string {
	return configFilename(strings.ToLower(c.property), group, configLocation)
}

func configFilename(baseFilename, group string, configLocation ConfigLocation) string {
	if group == DefaultGroup || group == "" {
		if configLocation == ParentConfig {
			return fmt.Sprintf("%s_parent.config", baseFilename)
		}
		return fmt.Sprintf("%s.config", baseFilename)
	}

	if configLocation == ParentConfig {
		return fmt.Sprintf("%s_%s_parent.config", baseFilename, group)
	}

	return fmt.Sprintf("%s_%s.config", baseFilename, group)
}
