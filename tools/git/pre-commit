#! /usr/bin/env bash
#
#  Simple pre-commit hook script, enforcing clang-format on our tree
#
#  Licensed to the Apache Software Foundation (ASF) under one
#  or more contributor license agreements.  See the NOTICE file
#  distributed with this work for additional information
#  regarding copyright ownership.  The ASF licenses this file
#  to you under the Apache License, Version 2.0 (the
#  "License"); you may not use this file except in compliance
#  with the License.  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

GIT_TOP="$(git rev-parse --show-toplevel)"
source "$GIT_TOP/tools/clang-format.sh"

case $(uname -s) in
Darwin)
    FORMAT=${FORMAT:-${ROOT}/clang-format/clang-format.macos.$(uname -m)}
    ;;
Linux)
    FORMAT=${FORMAT:-${ROOT}/clang-format/clang-format.linux.$(uname -m)}
    ;;
*)
    echo "Leif needs to build a clang-format for $(uname -s)"
    exit 2
    ;;
esac

# If there is no clang-format in our git repo, then try from git config
[ ! -x "$FORMAT" ] && FORMAT=$(git config clangFormat.binary)

# Make sure we have some clang-format executable...
if [ ! -x "$FORMAT" ]; then
    echo "No clang-format found"
    exit 1
fi

# Check for uv which is required for yapf and cmake-format.
if ! command -v uv &> /dev/null; then
    echo "uv is not installed. Please install it: https://docs.astral.sh/uv/getting-started/installation/"
    exit 1
fi

# Get version variables from the formatting scripts.
source "$GIT_TOP/tools/yapf.sh"
source "$GIT_TOP/tools/cmake-format.sh"

# Where to store the patch
clang_patch_file=$(mktemp -t clang-format.XXXXXXXXXX)
yapf_patch_file=$(mktemp -t yapf.XXXXXXXXXX)
cmake_format_patch_file=$(mktemp -t cmake-format.XXXXXXXXXX)
trap "rm -f $clang_patch_file $yapf_patch_file $cmake_format_patch_file" 0 1 2 3 5 15

# Loop over all files that are changed, and produce a diff file
REPO_ROOT=$(cd $(dirname $0)/../.. && git rev-parse --show-toplevel)
YAPF_CONFIG=${REPO_ROOT}/.style.yapf
git diff-index --cached --diff-filter=ACMR --name-only HEAD | grep -vE "lib/(Catch2|fastlz|ls-hpack|swoc|yamlcpp)" |  while read file; do
    case "$file" in
    *.cc | *.c | *.h | *.h.in | *.cript)
        ${FORMAT} "$file" | diff -u "$file" - >>"$clang_patch_file"
        ;;
    # Keep this list of Python extensions the same with the list of
    # extensions searched for in the tools/yapf.sh script.
    *.py | *.cli.ext | *.test.ext)
        uv tool run --quiet yapf@${YAPF_VERSION} \
            --style ${YAPF_CONFIG} \
            --parallel \
            --diff \
            "$file" >>"$yapf_patch_file"
        ;;
    esac
done

# Now repeat the above for CMakeLists.txt files.
git diff-index --cached --diff-filter=ACMR --name-only HEAD | grep -E 'CMakeLists.txt|\.cmake$' | grep -vE "lib/(Catch2|fastlz|ls-hpack|swoc|yamlcpp)" | while read file; do
    uv tool run --quiet --from cmakelang@${CMAKE_FORMAT_VERSION} --with pyaml cmake-format "$file" | diff -u "$file" - >>"$cmake_format_patch_file"
done

if [ -s "$clang_patch_file" ]; then
    echo "The commit is not accepted, because clang-format does not match current"
    echo "requirements. Easiest to fix this is to run:"
    echo
    echo "    $ cmake --build <build_dir> --target format"
    exit 1
else
    echo "This commit complies with the current clang-format indentation rules."
    echo
fi

if [ -s "$yapf_patch_file" ]; then
    echo "The commit is not accepted because yapf reports issues with it."
    echo "The easiest way to fix this is to run:"
    echo
    echo "    $ cmake --build <build_dir> --target format"
    exit 1
else
    echo "This commit complies with the current yapf formatting rules."
    echo
fi

if [ -s "$cmake_format_patch_file" ]; then
    echo "The commit is not accepted because cmake-format reports issues with it."
    echo "The easiest way to fix this is to run:"
    echo
    echo "    $ cmake --build <build_dir> --target format"
    exit 1
else
    echo "This commit complies with the current cmake-format formatting rules."
    echo
fi

# Check for trailing whitespace in staged files.
TRAILING_WS=$(git diff-index --cached --diff-filter=ACMR --name-only HEAD | grep -vE "lib/(yamlcpp|Catch2|systemtap)" | grep -vE "\.(gold|test_input)$" | xargs git diff --cached | grep -E '^\+.*[[:space:]]$' || true)
if [ -n "$TRAILING_WS" ]; then
    echo "The commit is not accepted because it contains trailing whitespace."
    echo "The easiest way to fix this is to run:"
    echo
    echo "    $ cmake --build <build_dir> --target format"
    exit 1
else
    echo "This commit complies with the trailing whitespace rules."
    echo
fi

# Check for DOS carriage returns in staged files.
CR=$(printf '\r')
DOS_CR=$(git diff-index --cached --diff-filter=ACMR --name-only HEAD | grep -vE "lib/(yamlcpp|Catch2|systemtap)" | grep -vE "\.test_input$" | xargs git diff --cached | grep "^+.*${CR}$" || true)
if [ -n "$DOS_CR" ]; then
    echo "The commit is not accepted because it contains DOS carriage returns."
    echo "The easiest way to fix this is to run:"
    echo
    echo "    $ cmake --build <build_dir> --target format"
    exit 1
else
    echo "This commit complies with the DOS line ending rules."
    echo
fi

exit 0
