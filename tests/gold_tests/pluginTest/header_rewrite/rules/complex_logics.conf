#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# All rules use SEND_RESPONSE_HDR_HOOK so set-header operates on the
# response that the client sees.  CLIENT-HEADER and CLIENT-URL:PATH
# conditions always refer to the original client request regardless of hook.

# ---- Test: GROUP with [OR] on GROUP:END ----
# hrw4u: if (inbound.req.X-Group-A) || inbound.req.X-Group-B
cond %{SEND_RESPONSE_HDR_HOOK} [AND]
cond %{CLIENT-URL:PATH} /\/logic\/group-or$/ [AND]
cond %{GROUP}
    cond %{CLIENT-HEADER:X-Group-A} ="" [NOT]
cond %{GROUP:END} [OR]
cond %{CLIENT-HEADER:X-Group-B} ="" [NOT]
    set-header X-Group-Or-Result "matched"

# ---- Test: GROUP with [AND] on GROUP:END (explicit) ----
# hrw4u: if (inbound.req.X-And-A) && inbound.req.X-And-B
cond %{SEND_RESPONSE_HDR_HOOK} [AND]
cond %{CLIENT-URL:PATH} /\/logic\/group-and$/ [AND]
cond %{GROUP}
    cond %{CLIENT-HEADER:X-And-A} ="" [NOT]
cond %{GROUP:END} [AND]
cond %{CLIENT-HEADER:X-And-B} ="" [NOT]
    set-header X-Group-And-Result "matched"

# ---- Test: GROUP with [NOT] on GROUP:END ----
# hrw4u: if !(inbound.req.X-Not-A && inbound.req.X-Not-B)
cond %{SEND_RESPONSE_HDR_HOOK} [AND]
cond %{CLIENT-URL:PATH} /\/logic\/group-not$/ [AND]
cond %{GROUP}
    cond %{CLIENT-HEADER:X-Not-A} ="" [NOT]
    cond %{CLIENT-HEADER:X-Not-B} ="" [NOT]
cond %{GROUP:END} [NOT]
    set-header X-Group-Not-Result "matched"

# ---- Test: Nested GROUPs with mixed OR/AND ----
# hrw4u: if inbound.req.X-Outer-A && (inbound.req.X-Inner-A || inbound.req.X-Inner-B)
cond %{SEND_RESPONSE_HDR_HOOK} [AND]
cond %{CLIENT-URL:PATH} /\/logic\/nested-group$/ [AND]
cond %{CLIENT-HEADER:X-Outer-A} ="" [NOT]
cond %{GROUP}
    cond %{CLIENT-HEADER:X-Inner-A} ="" [NOT,OR]
    cond %{CLIENT-HEADER:X-Inner-B} ="" [NOT]
cond %{GROUP:END}
    set-header X-Nested-Group-Result "matched"

# ---- Test: Two GROUPs with OR between them ----
# hrw4u: if (inbound.req.X-Left-A && inbound.req.X-Left-B) || (inbound.req.X-Right-A && inbound.req.X-Right-B)
cond %{SEND_RESPONSE_HDR_HOOK} [AND]
cond %{CLIENT-URL:PATH} /\/logic\/two-groups$/ [AND]
cond %{GROUP}
    cond %{CLIENT-HEADER:X-Left-A} ="" [NOT]
    cond %{CLIENT-HEADER:X-Left-B} ="" [NOT]
cond %{GROUP:END} [OR]
cond %{GROUP}
    cond %{CLIENT-HEADER:X-Right-A} ="" [NOT]
    cond %{CLIENT-HEADER:X-Right-B} ="" [NOT]
cond %{GROUP:END}
    set-header X-Two-Groups-Result "matched"

# ---- Test: GROUP inside if/elif/else ----
# hrw4u:
#   if inbound.req.X-Branch == "alpha" && (inbound.req.X-Sub-A || inbound.req.X-Sub-B)
#     -> "alpha"
#   elif inbound.req.X-Branch == "beta"
#     -> "beta"
#   else
#     -> "other"
cond %{SEND_RESPONSE_HDR_HOOK} [AND]
cond %{CLIENT-URL:PATH} /\/logic\/if-group$/ [AND]
  if
    cond %{CLIENT-HEADER:X-Branch} ="alpha"
    cond %{GROUP}
        cond %{CLIENT-HEADER:X-Sub-A} ="" [NOT,OR]
        cond %{CLIENT-HEADER:X-Sub-B} ="" [NOT]
    cond %{GROUP:END}
      set-header X-If-Group-Result "alpha"
  elif
    cond %{CLIENT-HEADER:X-Branch} ="beta"
      set-header X-If-Group-Result "beta"
  else
    set-header X-If-Group-Result "other"
  endif

# ---- Test: GROUP with OR inside nested if ----
# hrw4u:
#   if inbound.req.X-Outer == "yes"
#     if (inbound.req.X-Case-A || inbound.req.X-Case-B)
#       -> "inner-match"
#     else
#       -> "inner-miss"
#   else
#     -> "outer-miss"
cond %{SEND_RESPONSE_HDR_HOOK} [AND]
cond %{CLIENT-URL:PATH} /\/logic\/nested-if-group$/ [AND]
  if
    cond %{CLIENT-HEADER:X-Outer} ="yes"
      if
        cond %{GROUP}
            cond %{CLIENT-HEADER:X-Case-A} ="" [NOT,OR]
            cond %{CLIENT-HEADER:X-Case-B} ="" [NOT]
        cond %{GROUP:END}
          set-header X-Nested-If-Result "inner-match"
      else
        set-header X-Nested-If-Result "inner-miss"
      endif
  else
    set-header X-Nested-If-Result "outer-miss"
  endif

# ---- Test: Complex expression: (A OR B) AND (C OR D) ----
# hrw4u: if (inbound.req.X-P || inbound.req.X-Q) && (inbound.req.X-R || inbound.req.X-S)
cond %{SEND_RESPONSE_HDR_HOOK} [AND]
cond %{CLIENT-URL:PATH} /\/logic\/complex-and-or$/ [AND]
cond %{GROUP}
    cond %{CLIENT-HEADER:X-P} ="" [NOT,OR]
    cond %{CLIENT-HEADER:X-Q} ="" [NOT]
cond %{GROUP:END} [AND]
cond %{GROUP}
    cond %{CLIENT-HEADER:X-R} ="" [NOT,OR]
    cond %{CLIENT-HEADER:X-S} ="" [NOT]
cond %{GROUP:END}
    set-header X-Complex-Result "matched"

# ---- Test: IP:CLIENT in GROUP with [OR]
# hrw4u: if (inbound.ip in {127.0.0.0/8}) || inbound.req.X-Outer == "true"
cond %{SEND_RESPONSE_HDR_HOOK} [AND]
cond %{CLIENT-URL:PATH} /\/logic\/ip-group-or$/ [AND]
cond %{GROUP}
    cond %{IP:CLIENT} {127.0.0.0/8}
cond %{GROUP:END} [OR]
cond %{CLIENT-HEADER:X-Outer} ="true"
    set-header X-Ip-Group-Or-Result "matched"

# ---- Test: GROUP as first condition after hook ----
# hrw4u: if (inbound.url.path ~ /\/logic\/group-first$/) && inbound.req.X-First-A
cond %{SEND_RESPONSE_HDR_HOOK} [AND]
cond %{GROUP}
    cond %{CLIENT-URL:PATH} /\/logic\/group-first$/
cond %{GROUP:END} [AND]
cond %{CLIENT-HEADER:X-First-A} ="" [NOT]
    set-header X-Group-First-Result "matched"
