# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
msgid ""
msgstr ""
"Project-Id-Version: Apache Traffic Server 4.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2013-11-08 17:57+0900\n"
"PO-Revision-Date: 2013-12-15 14:15+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../admin/http-proxy-caching.en.rst:4
msgid "HTTP Proxy Caching"
msgstr "HTTP プロキシーキャッシュ"

#: ../../admin/http-proxy-caching.en.rst:32
msgid "Understanding HTTP Web Proxy Caching"
msgstr "HTTP ウェブプロキシーキャッシュの理解"

#: ../../admin/http-proxy-caching.en.rst:44
msgid "Traffic Server receives a client request for a web object."
msgstr ""
"Traffic Server がウェブオブジェクトへのクライアントリクエストを受け取りま"
"す。"

#: ../../admin/http-proxy-caching.en.rst:58
msgid "A cache hit"
msgstr "キャッシュヒット"

#: ../../admin/http-proxy-caching.en.rst:60
msgid ""
"If the data in the cache is stale, then Traffic Server connects to the "
"origin server and checks if the object is still fresh (a :term:"
"`revalidation`). If it is, then Traffic Server immediately sends the cached "
"copy to the client."
msgstr ""
"キャッシュのデータが古い場合、Traffic Server はオリジンサーバーへ接続し、オ"
"ブジェクトが依然新しいかどうか確認します。( :term:`再確認` ) 新しい場合、"
"Traffic Server はすぐにキャッシュしているコピーをクライアントに送ります。"

#: ../../admin/http-proxy-caching.en.rst:76
msgid "A cache miss"
msgstr "キャッシュミス"

#: ../../admin/http-proxy-caching.en.rst:87
msgid "Ensuring Cached Object Freshness"
msgstr "キャッシュされたオブジェクトの新鮮さの保証"

#: ../../admin/http-proxy-caching.en.rst:89
msgid ""
"When Traffic Server receives a request for a web object, it first tries to "
"locate the requested object in its cache. If the object is in cache, then "
"Traffic Server checks to see if the object is fresh enough to serve. For "
"HTTP objects, Traffic Server supports optional author-specified expiration "
"dates. Traffic Server adheres to these expiration dates; otherwise, it "
"picks an expiration date based on how frequently the object is changing and "
"on administrator-chosen freshness guidelines. Objects can also be "
"revalidated by checking with the origin server to see if an object is still "
"fresh."
msgstr ""
"Traffic Server がウェブオブジェクトへのリクエストを受け取った際、最初にリク"
"エストされたオブジェクトをキャッシュから探します。オブジェクトがキャッシュに"
"ある場合、Traffic Server はオブジェクトが提供するのに十分新しいかどうかを確"
"認します。 Traffic Server は HTTP オブジェクトに作成者が指定した有効期限をサ"
"ポートしています。 Traffic Server はこれらの有効期限を固く守ります。つまり、"
"どれだけ頻繁にオブジェクトが変更されるかと、管理者が選んだフレッシュネスガイ"
"ドラインに基づいて、有効期限を選択します。オブジェクトはまた、依然として新し"
"いかどうかをオリジンサーバーへ見に行くことにより、再検証されます。"

#: ../../admin/http-proxy-caching.en.rst:100
msgid "HTTP Object Freshness"
msgstr "HTTP オブジェクトの新鮮さ"

#: ../../admin/http-proxy-caching.en.rst:105
msgid "**Checking the** ``Expires`` **or** ``max-age`` **header**"
msgstr "``Expires`` **や** ``max-age`` **ヘッダーの確認**"

#: ../../admin/http-proxy-caching.en.rst:107
msgid ""
"Some HTTP objects contain ``Expires`` headers or ``max-age`` headers that "
"explicitly define how long the object can be cached. Traffic Server "
"compares the current time with the expiration time to determine if the "
"object is still fresh."
msgstr ""
"いくつかの HTTP オブジェクトは ``Expire`` ヘッダーや ``max-age`` ヘッダーを"
"含んでいます。これらはオブジェクトがどれくらいの期間キャッシュできるかどうか"
"を明確に定義しています。 Traffic Server はオブジェクトが新しいかどうかを決定"
"するために、現在時刻と有効期限を比較します。"

#: ../../admin/http-proxy-caching.en.rst:112
msgid "**Checking the** ``Last-Modified`` **/** ``Date`` **header**"
msgstr "``Last-Modified`` **/** ``Date`` **ヘッダーの確認**"

#: ../../admin/http-proxy-caching.en.rst:114
msgid ""
"If an HTTP object has no ``Expires`` header or ``max-age`` header, then "
"Traffic Server can calculate a freshness limit using the following formula::"
msgstr ""
"HTTP オブジェクトが ``Expire`` ヘッダーや ``max-age`` ヘッダーを持っていない"
"場合、Traffic Server はフレッシュネスリミットを次の式で計算します。"

#: ../../admin/http-proxy-caching.en.rst:130
msgid "**Checking the absolute freshness limit**"
msgstr "**絶対フレッシュネスリミットの確認**"

#: ../../admin/http-proxy-caching.en.rst:146
msgid "Modifying Aging Factor for Freshness Computations"
msgstr "新鮮さの計算のための期間要素の変更"

#: ../../admin/http-proxy-caching.en.rst:148
msgid ""
"If an object does not contain any expiration information, then Traffic "
"Server can estimate its freshness from the ``Last-Modified`` and ``Date`` "
"headers. By default, Traffic Server stores an object for 10% of the time "
"that elapsed since it last changed. You can increase or reduce the "
"percentage according to your needs."
msgstr ""
"オブジェクトが有効期限に関する情報を持っていない場合、Traffic Server は "
"``Last-Modified`` と ``Date`` ヘッダーから新鮮さを見積もります。デフォルトで"
"は Traffic Server は最後に更新されてからの経過時間の 10 % キャッシュしま"
"す。 必要に応じて、増減することができます。"

#: ../../admin/http-proxy-caching.en.rst:156
msgid ""
"Change the value for :ts:cv:`proxy.config.http.cache.heuristic_lm_factor`."
msgstr ""
":ts:cv:`proxy.config.http.cache.heuristic_lm_factor` の値を変更してくださ"
"い。"

#: ../../admin/http-proxy-caching.en.rst:158
#: ../../admin/http-proxy-caching.en.rst:174
#: ../../admin/http-proxy-caching.en.rst:193
#: ../../admin/http-proxy-caching.en.rst:279
msgid ""
"Run the :option:`traffic_ctl config reload` command to apply the configuration "
"changes."
msgstr ""
"設定変更を適用するために :option:`traffic_ctl config reload` コマンドを実行してくださ"
"い。"

#: ../../admin/http-proxy-caching.en.rst:177
msgid "Specifying Header Requirements"
msgstr "必須ヘッダーの記述"

#: ../../admin/http-proxy-caching.en.rst:179
msgid ""
"To further ensure freshness of the objects in the cache, configure Traffic "
"Server to cache only objects with specific headers. By default, Traffic "
"Server caches all objects (including objects with no headers); you should "
"change the default setting only for specialized proxy situations. If you "
"configure Traffic Server to cache only HTTP objects with ``Expires`` or "
"``max-age`` headers, then the cache hit rate will be noticeably reduced "
"(since very few objects will have explicit expiration information)."
msgstr ""
"よりいっそうキャッシュしているオブジェクトの新鮮さを確かめるために、特定の"
"ヘッダーを持っているオブジェクトだけをキャッシュするように Traffic Server を"
"設定することができます。デフォルトでは Traffic Server は(ヘッダーがないもの"
"も含む)全てのオブジェクトをキャッシュします。特別なプロキシーの状況の場合の"
"みデフォルト設定を変更するべきです。Traffic Server を ``Expires`` もしくは "
"``max-age`` ヘッダーを持つオブジェクトだけをキャッシュするように設定した場"
"合、キャッシュヒット率は明らかに下がるでしょう。(とても少ないオブジェクトし"
"か明確な有効期限の情報をもっていないと考えられるためです。)"

#: ../../admin/http-proxy-caching.en.rst:196
msgid "Cache-Control Headers"
msgstr "Cache-Control ヘッダー"

#: ../../admin/http-proxy-caching.en.rst:224
msgid ""
"The ``max-stale`` header, sent by clients, permits Traffic Server to serve "
"stale objects provided they are not too old. Some browsers might be willing "
"to take slightly stale objects in exchange for improved performance, "
"especially during periods of poor Internet availability."
msgstr ""
"クライアントからの ``max-stale`` ヘッダーは Traffic Server に古すぎない失効"
"したオブジェクトを配信することを許可します。いくつかのブラウザーは特に貧弱な"
"インターネット環境にあるような場合パフォーマンスを向上させるため、わずかに失"
"効したオブジェクトを受け取ることを望むかもしれません。"

#: ../../admin/http-proxy-caching.en.rst:235
msgid "Revalidating HTTP Objects"
msgstr "HTTP オブジェクトの再検証"

#: ../../admin/http-proxy-caching.en.rst:242
msgid ""
"If the object is still fresh, then Traffic Server resets its freshness "
"limit and serves the object."
msgstr ""
"オブジェクトが依然として新鮮な場合、Traffic Server はフレッシュネスリミット"
"をリセットして、そのオブジェクトを配信します。"

#: ../../admin/http-proxy-caching.en.rst:245
msgid ""
"If a new copy of the object is available, then Traffic Server caches the "
"new object (thereby replacing the stale copy) and simultaneously serves the "
"object to the client."
msgstr ""
"オブジェクトの新しいコピーが有効な場合、Traffic Server は新しいオブジェクト"
"をキャッシュします。(従って、新鮮ではないコピーは置き換えられます)また、同時"
"にオブジェクトをクライアントに配信します。"

#: ../../admin/http-proxy-caching.en.rst:249
msgid ""
"If the object no longer exists on the origin server, then Traffic Server "
"does not serve the cached copy."
msgstr ""
"オブジェクトがオリジンサーバー上に存在しない場合、Traffic Server はキャッ"
"シュしたコピーを配信しません。"

#: ../../admin/http-proxy-caching.en.rst:252
msgid ""
"If the origin server does not respond to the revalidation query, then "
"Traffic Server serves the stale object along with a ``111 Revalidation "
"Failed`` warning."
msgstr ""
"オリジンサーバーが再検証の問い合わせに応答しない場合、Traffic Server は "
"``111 Revalidation Failed`` 警告と共に新鮮ではないオブジェクトを配信します。"

#: ../../admin/http-proxy-caching.en.rst:256
msgid ""
"By default, Traffic Server revalidates a requested HTTP object in the cache "
"if it considers the object to be stale. Traffic Server evaluates object "
"freshness as described in `HTTP Object Freshness`_. You can reconfigure how "
"Traffic Server evaluates freshness by selecting one of the following "
"options:"
msgstr ""
"デフォルトでは Traffic Server はリクエストされた HTTP オブジェクトが新鮮では"
"ないと考えられる場合に再検証します。Traffic Server のオブジェクトの新鮮さの"
"評価については `HTTP オブジェクトの新鮮さ`_ で述べられています。次のオプショ"
"ンの一つを選ぶことによって、 Traffic Server が新鮮さを評価する方法を再設定す"
"ることができます。"

#: ../../admin/http-proxy-caching.en.rst:271
msgid ""
"To configure how Traffic Server revalidates objects in the cache, you can "
"set specific revalidation rules in :file:`cache.config`."
msgstr ""
"Traffic Server がキャッシュしているオブジェクトを再検証する方法を設定するに"
"は :file:`cache.config` に特定の再検証のルールを設定してください。"

#: ../../admin/http-proxy-caching.en.rst:274
msgid "To configure revalidation options"
msgstr "再検証のオプションを設定するには"

#: ../../admin/http-proxy-caching.en.rst:303
#: ../../admin/http-proxy-caching.en.rst:358
#: ../../admin/http-proxy-caching.en.rst:411
#: ../../admin/http-proxy-caching.en.rst:455
#: ../../admin/http-proxy-caching.en.rst:481
#: ../../admin/http-proxy-caching.en.rst:518
#: ../../admin/http-proxy-caching.en.rst:539
#: ../../admin/http-proxy-caching.en.rst:566
#: ../../admin/http-proxy-caching.en.rst:582
#: ../../admin/http-proxy-caching.en.rst:610
#: ../../admin/http-proxy-caching.en.rst:638
#: ../../admin/http-proxy-caching.en.rst:670
msgid ""
"Run the command :option:`traffic_ctl config reload` to apply the configuration "
"changes."
msgstr ""
"設定変更を適用するために :option:`traffic_ctl config reload` を実行してください。"

#: ../../admin/http-proxy-caching.en.rst:284
msgid "Pushing Content into the Cache"
msgstr "コンテンツのキャッシュへのプッシュ"

#: ../../admin/http-proxy-caching.en.rst:286
msgid ""
"Traffic Server supports the HTTP ``PUSH`` method of content delivery. Using "
"HTTP ``PUSH``, you can deliver content directly into the cache without "
"client requests."
msgstr ""
"Traffic Server はコンテンツ配信に HTTP ``PUSH`` メソッドをサポートして いま"
"す。HTTP ``PUSH`` を使用すると、クライアントからのリクエスト無しに直接コンテ"
"ンツをキャッシュの中に入れることができます。"

#: ../../admin/http-proxy-caching.en.rst:291
msgid "Configuring Traffic Server for PUSH Requests"
msgstr "PUSH リクエスト用の Traffic Server の設定"

#: ../../admin/http-proxy-caching.en.rst:293
msgid ""
"Before you can deliver content into your cache using HTTP ``PUSH``, you "
"must configure Traffic Server to accept ``PUSH`` requests."
msgstr ""
"HTTP ``PUSH`` を使用してコンテンツをキャッシュの中に入れる前に、Traffic "
"Server が ``PUSH`` リクエストを受け入れるように設定する必要があります。"

#: ../../admin/http-proxy-caching.en.rst:306
msgid "Understanding HTTP PUSH"
msgstr "HTTP PUSH の理解"

#: ../../admin/http-proxy-caching.en.rst:308
msgid ""
"``PUSH`` uses the HTTP 1.1 message format. The body of a ``PUSH`` request "
"contains the response header and response body that you want to place in "
"the cache. The following is an example of a ``PUSH`` request::"
msgstr ""
"``PUSH`` は HTTP 1.1 メッセージフォーマットを使用します。 ``PUSH`` リクエス"
"トのボディはキャッシュに入れたいレスポンスヘッダーとレスポンスボディを含みま"
"す。下記は ``PUSH`` リクエストの例です。"

#: ../../admin/http-proxy-caching.en.rst:331
msgid "Tools that will help manage pushing"
msgstr "プッシュを手助けするツール"

#: ../../admin/http-proxy-caching.en.rst:338
msgid "Pinning Content in the Cache"
msgstr "コンテンツのキャッシュへのピン留め"

#: ../../admin/http-proxy-caching.en.rst:353
msgid ""
"Add a rule in :file:`cache.config` for each URL you want Traffic Server to "
"pin in the cache. For example::"
msgstr ""
"Traffic Server にキャッシュに留めさせたい URL 毎に :file:`cache.config` に"
"ルールを追加してください。例:"

#: ../../admin/http-proxy-caching.en.rst:363
msgid ""
"When Traffic Server receives a request for a web object that is not in the "
"cache, it retrieves the object from the origin server and serves it to the "
"client. At the same time, Traffic Server checks if the object is cacheable "
"before storing it in its cache to serve future requests."
msgstr ""
"Traffic Server がキャッシュしていないウェブオブジェクトへのリクエストを受け"
"取った際、オリジンサーバーからオブジェクトを回収し、クライアントに配信しま"
"す。その際に、Traffic Server は将来のリクエストに備えてキャッシュに保存する"
"前に、オブジェクトがキャッシュ可能かどうか確認します。"

#: ../../admin/http-proxy-caching.en.rst:361
msgid "Caching HTTP Objects"
msgstr "HTTP オブジェクトのキャッシュ"

#: ../../admin/http-proxy-caching.en.rst:368
msgid ""
"Traffic Server responds to caching directives from clients and origin "
"servers, as well as directives you specify through configuration options "
"and files."
msgstr ""
"Traffic Server は設定オプションやファイルに指定したディレクティブと同じよう"
"に、クライアントやオリジンサーバーからのキャッシュのディレクティブに反応しま"
"す。"

#: ../../admin/http-proxy-caching.en.rst:373
msgid "Client Directives"
msgstr "クライアントディレクティブ"

#: ../../admin/http-proxy-caching.en.rst:389
msgid ""
"By default, Traffic Server caches objects served in response to requests "
"that contain cookies (unless the object is text). You can configure Traffic "
"Server to not cache cookied content of any type, cache all cookied content, "
"or cache cookied content that is of image type only. For more information, "
"refer to `Caching Cookied Objects`_."
msgstr ""
"デフォルトでは、クッキーを含むリクエストへ返されるオブジェクト(テキストを除"
"くオブジェクト) を Traffic Server はキャッシュします。Traffic Server を次の"
"用に設定することができます。クッキーを持ったどんなタイプのコンテンツでも"
"キャッシュしない、クッキーを持った全てのコンテンツをキャッシュする、もしくは"
"クッキーを持った画像だけをキャッシュする。より詳しくは `クッキーオブジェクト"
"のキャッシュ`_ を参照してください。"

#: ../../admin/http-proxy-caching.en.rst:396
msgid "Configuring Traffic Server to Ignore Client no-cache Headers"
msgstr "クライアントの no-cache ヘッダーを無視する Traffic Server の設定"

#: ../../admin/http-proxy-caching.en.rst:398
msgid ""
"By default, Traffic Server strictly observes client ``Cache-Control: no-"
"cache`` directives. If a requested object contains a ``no-cache`` header, "
"then Traffic Server forwards the request to the origin server even if it "
"has a fresh copy in cache. You can configure Traffic Server to ignore "
"client ``no-cache`` directives such that it ignores ``no-cache`` headers "
"from client requests and serves the object from its cache."
msgstr ""
"デフォルトでは Traffic Server はクライアントの ``Cache-Control: no-cache`` "
"ディレクティブを正確に守ります。リクエストされたオブジェクトが ``no-cache`` "
"を含んでいる場合、Traffic Server はキャッシュのコピーが新鮮であったとして"
"も、オリジンサーバーにリクエストを転送します。Traffic Server がクライアント"
"からの ``no-cache`` ディレクティブを無視するように設定することもできます。こ"
"の場合、クライアントからのリクエストの ``no-cache`` ヘッダーを無視して、"
"キャッシュからオブジェクトを配信します。"

#: ../../admin/http-proxy-caching.en.rst:414
msgid "Origin Server Directives"
msgstr "オリジンサーバーディレクティブ"

#: ../../admin/http-proxy-caching.en.rst:425
msgid ""
"To configure Traffic Server to ignore ``WWW-Authenticate`` headers, refer "
"to `Configuring Traffic Server to Ignore WWW-Authenticate Headers`_."
msgstr ""
"``WWW-Authenticate`` ヘッダーを無視するように Traffic Server を設定 するに"
"は `WWW-Authenticate ヘッダーを無視する Traffic Server の設定`_ を参照してく"
"ださい。"

#: ../../admin/http-proxy-caching.en.rst:432
msgid ""
"To configure Traffic Server to ignore ``no-cache`` headers, refer to "
"`Configuring Traffic Server to Ignore Server no-cache Headers`_."
msgstr ""
"``no-cache`` ヘッダーを無視するように Traffic Server を設定するには `サー"
"バーの no-cache ヘッダーを無視する Traffic Server の設定`_ を参照してくださ"
"い。"

#: ../../admin/http-proxy-caching.en.rst:438
msgid "Configuring Traffic Server to Ignore Server no-cache Headers"
msgstr "サーバーの no-cache ヘッダーを無視する Traffic Server の設定"

#: ../../admin/http-proxy-caching.en.rst:440
msgid ""
"By default, Traffic Server strictly observes ``Cache-Control: no-cache`` "
"directives. A response from an origin server with a ``no-cache`` header is "
"not stored in the cache and any previous copy of the object in the cache is "
"removed. If you configure Traffic Server to ignore ``no-cache`` headers, "
"then Traffic Server also ignores ``no-store`` headers. The default behavior "
"of observing ``no-cache`` directives is appropriate in most cases."
msgstr ""
"デフォルトでは Traffic Server は ``Cache-Control: no-cache`` ディレクティブ"
"を正確に守ります。``no-cache`` ヘッダーが付いているオリジンサーバーからのレ"
"スポンスはキャッシュに保存されません。また、以前キャッシュされたオブジェクト"
"のコピーは削除されます。 ``no-cache`` ヘッダーを無視するように Traffic "
"Server を設定した場合、Traffic Server は ``no-store`` ヘッダーも無視します。"
"``no-cache`` ディレクティブを守るデフォルトの振る舞いはほとんどの場合に適切"
"です。"

#: ../../admin/http-proxy-caching.en.rst:458
msgid "Configuring Traffic Server to Ignore WWW-Authenticate Headers"
msgstr "WWW-Authenticate ヘッダーを無視する Traffic Server の設定"

#: ../../admin/http-proxy-caching.en.rst:460
msgid ""
"By default, Traffic Server does not cache objects that contain ``WWW-"
"Authenticate`` response headers. The ``WWW-Authenticate`` header contains "
"authentication parameters the client uses when preparing the authentication "
"challenge response to an origin server."
msgstr ""
"デフォルトでは Traffic Server は ``WWW-Authenticate`` レスポンスヘッダーを含"
"むオブジェクトをキャッシュしません。 ``WWW-Authenticate`` ヘッダーはクライア"
"ントがオリジンサーバーへのチャレンジレスポンス認証の際に使う認証パラメーター"
"を含んでいます。"

#: ../../admin/http-proxy-caching.en.rst:465
msgid ""
"When you configure Traffic Server to ignore origin server ``WWW-"
"Authenticate`` headers, all objects with ``WWW-Authenticate`` headers are "
"stored in the cache for future requests. However, the default behavior of "
"not caching objects with ``WWW-Authenticate`` headers is appropriate in "
"most cases. Only configure Traffic Server to ignore server ``WWW-"
"Authenticate`` headers if you are knowledgeable about HTTP 1.1."
msgstr ""
"オリジンサーバーの ``WWW-Authenticate`` ヘッダーを無視するように Traffic "
"Server を設定した場合、 ``WWW-Authenticate`` ヘッダーを持つ全てのオブジェク"
"トは次のリクエストの為にキャッシュに保存されます。しかし、 ``WWW-"
"Authenticate`` ヘッダーを持つオブジェクトをキャッシュしないデフォルトの振る"
"舞いは多くの場合に適切です。 ``WWW-Authenticate`` ヘッダーを無視するように "
"Traffic Server を設定するのは HTTP 1.1 に精通してる場合にだけにしてくださ"
"い。"

#: ../../admin/http-proxy-caching.en.rst:484
msgid "Configuration Directives"
msgstr "設定ディレクティブ"

#: ../../admin/http-proxy-caching.en.rst:486
msgid ""
"In addition to client and origin server directives, Traffic Server responds "
"to directives you specify through configuration options and files."
msgstr ""
"クライアントやオリジンサーバーのディレクティブに加えて、Traffic Server は設"
"定オプションやファイルを通じて設定したディレクティブにも反応します。"

#: ../../admin/http-proxy-caching.en.rst:490
msgid "You can configure Traffic Server to do the following:"
msgstr "次のように Traffic Server を設定することができます。"

#: ../../admin/http-proxy-caching.en.rst:504
msgid "Disabling HTTP Object Caching"
msgstr "HTTP オブジェクトキャッシュの無効化"

#: ../../admin/http-proxy-caching.en.rst:521
msgid "Caching Dynamic Content"
msgstr "動的コンテンツのキャッシュ"

#: ../../admin/http-proxy-caching.en.rst:542
msgid "Caching Cookied Objects"
msgstr "クッキーオブジェクトのキャッシュ"

#: ../../admin/http-proxy-caching.en.rst:546
msgid ""
"By default, Traffic Server caches objects served in response to requests "
"that contain cookies. This is true for all types of objects except for "
"text. Traffic Server does not cache cookied text content because object "
"headers are stored along with the object, and personalized cookie header "
"values could be saved with the object. With non-text objects, it is "
"unlikely that personalized headers are delivered or used."
msgstr ""
"デフォルトではクッキーを含むリクエストに対するレスポンスとして配信されたオブ"
"ジェクトを Traffic Server はキャッシュします。これはテキストを除いた全てのタ"
"イプのオブジェクトについても同じです。Traffic Server はクッキーをもつテキス"
"トコンテンツをキャッシュしません。それはオブジェクトのヘッダーはオブジェクト"
"共に保存され、個人的なクッキーヘッダーの値もオブジェクトと共に保存されるため"
"です。テキストではないオブジェクトの場合、個人的なヘッダーは配信されたり使わ"
"れたりしません。"

#: ../../admin/http-proxy-caching.en.rst:553
msgid "You can reconfigure Traffic Server to:"
msgstr "次のように Traffic Server を設定し直すことができます。"

#: ../../admin/http-proxy-caching.en.rst:557
msgid "Cache cookied content that is of image type only."
msgstr "クッキーを含む画像のみキャッシュする"

#: ../../admin/http-proxy-caching.en.rst:559
msgid "Cache all cookied content regardless of type."
msgstr "タイプを考慮せずクッキーを含む全てのコンテンツをキャッシュする"

#: ../../admin/http-proxy-caching.en.rst:569
msgid "Forcing Object Caching"
msgstr "オブジェクトの強制キャッシュ"

#: ../../admin/http-proxy-caching.en.rst:571
msgid ""
"You can force Traffic Server to cache specific URLs (including dynamic "
"URLs) for a specified duration, regardless of ``Cache-Control`` response "
"headers."
msgstr ""
"``Cache-Control`` レスポンスヘッダーを無視して、特定の期間に特定の URL (動"
"的 URL も含む) をキャッシュすることを Traffic Server に強制することができま"
"す。"

#: ../../admin/http-proxy-caching.en.rst:577
msgid ""
"Add a rule for each URL you want Traffic Server to pin to the cache :file:"
"`cache.config`::"
msgstr ""
"Traffic Server にキャッシュに留めさせたい URL 毎に :file:`cache.config` に"
"ルールを追加してください。"

#: ../../admin/http-proxy-caching.en.rst:585
msgid "Caching HTTP Alternates"
msgstr "HTTP オブジェクトの代替のキャッシュ"

#: ../../admin/http-proxy-caching.en.rst:599
msgid "Configuring How Traffic Server Caches Alternates"
msgstr "Traffic Server がキャッシュする代替の設定"

#: ../../admin/http-proxy-caching.en.rst:605
msgid ":ts:cv:`proxy.config.http.cache.enable_default_vary_headers`"
msgstr ":ts:cv:`proxy.config.http.cache.enable_default_vary_headers`"

#: ../../admin/http-proxy-caching.en.rst:606
msgid ":ts:cv:`proxy.config.http.cache.vary_default_text`"
msgstr ":ts:cv:`proxy.config.http.cache.vary_default_text`"

#: ../../admin/http-proxy-caching.en.rst:607
msgid ":ts:cv:`proxy.config.http.cache.vary_default_images`"
msgstr ":ts:cv:`proxy.config.http.cache.vary_default_images`"

#: ../../admin/http-proxy-caching.en.rst:608
msgid ":ts:cv:`proxy.config.http.cache.vary_default_other`"
msgstr ":ts:cv:`proxy.config.http.cache.vary_default_other`"

#: ../../admin/http-proxy-caching.en.rst:614
msgid ""
"If you specify ``Cookie`` as the header field on which to vary in the above "
"variables, make sure that the variable :ts:cv:`proxy.config.http.cache."
"cache_responses_to_cookies` is set appropriately."
msgstr ""
"上の変数に ``Cookie`` を切り替えるためのヘッダーフィールドとして指定した場"
"合、 :ts:cv:`proxy.config.http.cache.cache_responses_to_cookies` が適切に"
"セットされていることを確認して下さい。"

#: ../../admin/http-proxy-caching.en.rst:620
msgid "Limiting the Number of Alternates for an Object"
msgstr "オブジェクトの代替数の制限"

#: ../../admin/http-proxy-caching.en.rst:622
msgid ""
"You can limit the number of alternates Traffic Server can cache per object "
"(the default is 3)."
msgstr ""
"Traffic Server がオブジェクト毎にキャッシュする代替数を制限することができま"
"す。(デフォルトは 3 です)"

#: ../../admin/http-proxy-caching.en.rst:627
msgid ""
"Large numbers of alternates can affect Traffic Server cache performance "
"because all alternates have the same URL. Although Traffic Server can look "
"up the URL in the index very quickly, it must scan sequentially through "
"available alternates in the object store."
msgstr ""
"全ての代替は同一の URL を持つため、代替の数が多いと Traffic Server のキャッ"
"シュパフォーマンスに影響を与えるかもしれません。Traffic Server はインデック"
"ス中の URL をとても高速に検索しますが、キャッシュストアの中に使用可能な代替"
"があるかはシーケンシャルにスキャンしなければなりません。"

#: ../../admin/http-proxy-caching.en.rst:643
msgid "Using Congestion Control"
msgstr "輻輳制御"

#: ../../admin/http-proxy-caching.en.rst:675
msgid "Using Transaction Buffering Control"
msgstr "トランザクションバッファリング制御"

#: ../../admin/http-proxy-caching.en.rst:686
msgid ""
"This problem can be ameloriated by controlling the amount of buffer space "
"used by a transaction. A high water and low water mark are set in terms of "
"bytes used by the transaction. If the buffer space in use exceeds the high "
"water mark, the connection is throttled to prevent additional external data "
"from arriving. Internal operations continue to proceed at full speed until "
"the buffer space in use drops below the low water mark and external data I/"
"O is re-enabled."
msgstr ""
"この問題はトランザクションが使うバッファースペースの量をコントロールすること"
"で改善されるかもしれません。high water と low water マークはトランザクション"
"で使用されるバイトの幅をセットします。バッファースペースが high water マーク"
"を越えた場合、コネクションは追加のデータがやってくることを止める為に減速しま"
"す。使われているバッファースペースが low water マークを下回り、外部のデータ "
"I/O が再開されるまで内側のオペレーションはフルスピードで進み続けます。"

#: ../../admin/http-proxy-caching.en.rst:694
msgid ""
"Although this is intended primarily to limit the memory usage of Traffic "
"Server it can also serve as a crude rate limiter by setting a buffer limit "
"and then throttling the client side connection either externally or via a "
"transform. This will cause the connection to the origin server to be "
"limited to roughly the client side connection speed."
msgstr ""
"主に Traffic Server のメモリ使用量を制限することを意図していますが、これはま"
"た大雑把なレートリミッターも提供します。これはバッファーリミットの設定と、外"
"部やトランスフォームの影響により、クライアント側のコネクションを減速させるこ"
"とによります。これはオリジンサーバーへのコネクションがクライアント側のコネク"
"ションスピードにより大まかに制限されることをもたします。"

#: ../../admin/http-proxy-caching.en.rst:700
msgid ""
"Traffic Server does network I/O in large chunks (32K or so) and therefore "
"the granularity of transaction buffering control is limited to a similar "
"precision."
msgstr ""
"Traffic Server はネットワーク I/O をラージチャンク(32K など) で行います。"
"よって、トランザクションバッファリングコントロールの粒度は同じような値に制限"
"されています。"

#: ../../admin/http-proxy-caching.en.rst:703
msgid ""
"The buffer size calculations include all elements in the transaction, "
"including any buffers associated with :ref:`transform plugins <transform-"
"plugin>`."
msgstr ""
"バッファーサイズの計算はトランザクションの全ての要素を含んでいます。これは :"
"ref:`transform plugins <transform-plugin>` に紐づけられているどんなバッ"
"ファーも含みます。"

#: ../../admin/http-proxy-caching.en.rst:706
msgid ""
"Transaction buffering control can be enabled globally by using "
"configuration variables or by :c:func:`TSHttpTxnConfigIntSet` in a plugin."
msgstr ""
"トランザクションバッファーコントロールは設定変数を使ってグローバルに有効化す"
"ることもできます。また :c:func:`TSHttpTxnConfigIntSet` を使用してプラグイン"
"の中で有効化することもできます。"

#: ../../admin/http-proxy-caching.en.rst:710
msgid "Value"
msgstr "値"

#: ../../admin/http-proxy-caching.en.rst:710
msgid "Variable"
msgstr "変数"

#: ../../admin/http-proxy-caching.en.rst:712
msgid "Enable buffering"
msgstr "バッファーの有効化"

#: ../../admin/http-proxy-caching.en.rst:712
msgid ":ts:cv:`proxy.config.http.flow_control.enabled`"
msgstr ":ts:cv:`proxy.config.http.flow_control.enabled`"

#: ../../admin/http-proxy-caching.en.rst:713
msgid "Set high water"
msgstr "high water の設定"

#: ../../admin/http-proxy-caching.en.rst:713
msgid ":ts:cv:`proxy.config.http.flow_control.high_water`"
msgstr ":ts:cv:`proxy.config.http.flow_control.high_water`"

#: ../../admin/http-proxy-caching.en.rst:714
msgid "Set low water"
msgstr "low water の設定"

#: ../../admin/http-proxy-caching.en.rst:714
msgid ":ts:cv:`proxy.config.http.flow_control.low_water`"
msgstr ":ts:cv:`proxy.config.http.flow_control.low_water`"

#: ../../admin/http-proxy-caching.en.rst:717
msgid ""
"Be careful to always have the low water mark equal or less than the high "
"water mark. If you set only one, the other will be set to the same value."
msgstr ""
"low water マークは high water マークと常に同じか少ないことに注意してくださ"
"い。一方だけを設定すると、もう一方は同じ値に設定されます。"

#: ../../admin/http-proxy-caching.en.rst:726
msgid "Reducing Origin Server Requests (Avoiding the Thundering Herd)"
msgstr "オリジンサーバーへのリクエストの削減(Thundering Herd 問題を避ける)"

#: ../../admin/http-proxy-caching.en.rst:728
msgid ""
"When an object can not be served from cache, the request will be proxied to "
"the origin server. For a popular object, this can result in many near "
"simultaneous requests to the origin server, potentially overwhelming it or "
"associated resources. There are several features in Traffic Server that can "
"be used to avoid this scenario."
msgstr ""
"オブジェクトがキャッシュから配信されない場合、リクエストはオリジンサーバーに"
"プロキシーされます。ポピュラーなオブジェクトにとって、これはオリジンサーバー"
"へ多くの同じ様なリクエストを送り、可能性としては計り知れない程の関連したリ"
"ソースを使うかもしれません。Traffic Server にはこのシナリオを避けられるいく"
"つかの機能があります。"

#: ../../admin/http-proxy-caching.en.rst:735
msgid "Read While Writer"
msgstr "Read While Writer"

#: ../../admin/http-proxy-caching.en.rst:762
msgid "All four configurations are required, for the following reasons:"
msgstr "次の理由により、４つ全ての設定が必要です。"

#: ../../admin/http-proxy-caching.en.rst:788
msgid "Fuzzy Revalidation"
msgstr "Fuzzy Revalidation"

#: ../../admin/http-proxy-caching.en.rst:842
msgid "Open Read Retry Timeout"
msgstr "Open Read Retry Timeout"

#: ../../admin/http-proxy-caching.en.rst:871
msgid ""
"Since ATS now supports setting these settings per-request or remap rule, "
"you can configure this to be suitable for your setup much more easily."
msgstr ""
"ATS はリクエスト毎や remap ルールに設定することをサポートしているので、これ"
"はより簡単に適切に設定することができます。"

#: ../../admin/http-proxy-caching.en.rst:23
msgid ""
"HTTP proxy caching enables you to store copies of frequently-accessed web "
"objects (such as documents, images, and articles) and then serve this "
"information to users on demand. It improves performance and frees up "
"Internet bandwidth for other tasks."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:34
msgid ""
"Internet users direct their requests to web servers all over the Internet. "
"A caching server must act as a *web proxy server* so it can serve those "
"requests. After a web proxy server receives requests for web objects, it "
"either serves the requests or forwards them to the *origin server* (the web "
"server that contains the original copy of the requested information). The "
"Traffic Server proxy supports *explicit proxy caching*, in which the user's "
"client software must be configured to send requests directly to the Traffic "
"Server proxy. The following overview illustrates how Traffic Server serves "
"a request."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:46
msgid ""
"Using the object address, Traffic Server tries to locate the requested "
"object in its object database (*cache*)."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:49
msgid ""
"If the object is in the cache, then Traffic Server checks to see if the "
"object is fresh enough to serve. If it is fresh, then Traffic Server serves "
"it to the client as a *cache hit* (see the figure below)."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:65
msgid ""
"If the object is not in the cache (a *cache miss*) or if the server "
"indicates the cached copy is no longer valid, then Traffic Server obtains "
"the object from the origin server. The object is then simultaneously "
"streamed to the client and the Traffic Server local cache (see the figure "
"below). Subsequent requests for the object can be served faster because the "
"object is retrieved directly from cache."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:78
msgid ""
"Caching is typically more complex than the preceding overview suggests. In "
"particular, the overview does not discuss how Traffic Server ensures "
"freshness, serves correct HTTP alternates, and treats requests for objects "
"that cannot or should not be cached. The following sections discuss these "
"issues in greater detail."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:102
msgid ""
"Traffic Server determines whether an HTTP object in the cache is fresh by "
"checking the following conditions in order:"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:120
msgid ""
"where *date* is the date in the object's server response header and "
"*last_modified* is the date in the ``Last-Modified`` header. If there is no "
"``Last-Modified`` header, then Traffic Server uses the date the object was "
"written to cache. The value ``0.10`` (10 percent) can be increased or "
"reduced to better suit your needs. Refer to `Modifying Aging Factor for "
"Freshness Computations`_."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:127
msgid ""
"The computed freshness limit is bound by a minimum and maximum value. Refer "
"to `Setting Absolute Freshness Limits`_ for more information."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:132
msgid ""
"For HTTP objects that do not have ``Expires`` headers or do not have both "
"``Last-Modified`` and ``Date`` headers, Traffic Server uses a maximum and "
"minimum freshness limit. Refer to `Setting Absolute Freshness Limits`_."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:137
msgid "**Checking revalidate rules in** :file:`cache.config`"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:139
msgid ""
"Revalidate rules apply freshness limits to specific HTTP objects. You can "
"set freshness limits for objects originating from particular domains or IP "
"addresses, objects with URLs that contain specified regular expressions, "
"objects requested by particular clients, and so on. Refer to :file:`cache."
"config`."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:154
msgid "To modify the aging factor for freshness computations:"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:161
msgid "Setting Absolute Freshness Limits"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:163
msgid ""
"Some objects do not have ``Expires`` headers or do not have both ``Last-"
"Modified`` and ``Date`` headers. To control how long these objects are "
"considered fresh in the cache, specify an *absolute freshness limit*."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:168
msgid "To specify an absolute freshness limit:"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:170
msgid ""
"Edit the variables :ts:cv:`proxy.config.http.cache.heuristic_min_lifetime` "
"and :ts:cv:`proxy.config.http.cache.heuristic_max_lifetime` in :file:"
"`records.config`."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:188
msgid "To configure Traffic Server to cache objects with specific headers:"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:190
msgid ""
"Change the value for :ts:cv:`proxy.config.http.cache.required_headers` in :"
"file:`records.config`."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:198
msgid ""
"Even though an object might be fresh in the cache, clients or servers often "
"impose their own constraints that preclude retrieval of the object from the "
"cache. For example, a client might request that a object not be retrieved "
"from a cache, or if it does allow cache retrieval, then it cannot have been "
"cached for more than 10 minutes."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:204
msgid ""
"Traffic Server bases the servability of a cached object on ``Cache-"
"Control`` headers that appear in both client requests and server responses. "
"The following ``Cache-Control`` headers affect whether objects are served "
"from cache:"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:208
msgid ""
"The ``no-cache`` header, sent by clients, tells Traffic Server that it "
"should not serve any objects directly from the cache. When present in a "
"client request, Traffic Server will always obtain the object from the "
"origin server. You can configure Traffic Server to ignore client ``no-"
"cache`` headers. Refer to `Configuring Traffic Server to Ignore Client no-"
"cache Headers`_ for more information."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:215
msgid ""
"The ``max-age`` header, sent by servers, is compared to the object age. If "
"the age is less than ``max-age``, then the object is fresh and can be "
"served from the Traffic Server cache."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:219
msgid ""
"The ``min-fresh`` header, sent by clients, is an *acceptable freshness "
"tolerance*. This means that the client wants the object to be at least this "
"fresh. Unless a cached object remains fresh at least this long in the "
"future, it is revalidated."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:230
msgid ""
"Traffic Server applies ``Cache-Control`` servability criteria after HTTP "
"freshness criteria. For example, an object might be considered fresh but "
"will not be served if its age is greater than its ``max-age``."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:237
msgid ""
"When a client requests an HTTP object that is stale in the cache, Traffic "
"Server revalidates the object. A *revalidation* is a query to the origin "
"server to check if the object is unchanged. The result of a revalidation is "
"one of the following:"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:263
msgid "*Traffic Server considers all HTTP objects in the cache to be stale:*"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:263
msgid "Always revalidate HTTP objects in the cache with the origin server."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:266
msgid "*Traffic Server considers all HTTP objects in the cache to be fresh:*"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:266
msgid "Never revalidate HTTP objects in the cache with the origin server."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:269
msgid ""
"*Traffic Server considers all HTTP objects without* ``Expires`` *or* "
"``Cache-control`` *headers to be stale:*"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:269
msgid ""
"Revalidate all HTTP objects without ``Expires`` or ``Cache-Control`` "
"headers."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:276
msgid ""
"Edit the variable :ts:cv:`proxy.config.http.cache.when_to_revalidate` in :"
"file:`records.config`."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:296
msgid ""
"Edit :file:`ip_allow.config` to allow ``PUSH`` from the appropriate "
"addresses."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:298
msgid ""
"Update :ts:cv:`proxy.config.http.push_method_enabled` in :file:`records."
"config`::"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:325
msgid ""
"Your ``PUSH`` headers must include ``Content-length``, the value for which "
"must include both headers and body byte counts. The value is not optional, "
"and an improper (too large or too small) value will result in undesirable "
"behavior."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:333
msgid ""
"Traffic Server comes with a Perl script for pushing, :program:`tspush`, "
"which can assist with understanding how to write scripts for pushing "
"content yourself."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:340
msgid ""
"The *Cache Pinning Option* configures Traffic Server to keep certain HTTP "
"objects in the cache for a specified time. You can use this option to "
"ensure that the most popular objects are in cache when needed and to "
"prevent Traffic Server from deleting important objects. Traffic Server "
"observes ``Cache-Control`` headers and pins an object in the cache only if "
"it is indeed cacheable."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:347
msgid "To set cache pinning rules:"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:349
msgid ""
"Enable :ts:cv:`proxy.config.cache.permit.pinning` in :file:`records."
"config`::"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:375
msgid ""
"By default, Traffic Server does not cache objects with the following "
"request headers:"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:378
msgid "``Authorization``"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:380
#: ../../admin/http-proxy-caching.en.rst:419
msgid "``Cache-Control: no-store``"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:382
#: ../../admin/http-proxy-caching.en.rst:430
msgid "``Cache-Control: no-cache``"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:384
msgid ""
"To configure Traffic Server to ignore this request header, refer to "
"`Configuring Traffic Server to Ignore Client no-cache Headers`_."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:387
msgid "``Cookie`` (for text objects)"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:406
msgid ""
"Edit :ts:cv:`proxy.config.http.cache.ignore_client_no_cache` in :file:"
"`records.config`. ::"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:416
msgid ""
"By default, Traffic Server does not cache objects with the following "
"response headers:"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:421
msgid "``Cache-Control: private``"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:423
msgid "``WWW-Authenticate``"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:428
msgid "``Set-Cookie``"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:435
msgid "``Expires`` header with a value of 0 (zero) or a past date."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:448
msgid "To configure Traffic Server to ignore server ``no-cache`` headers:"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:450
msgid ""
"Edit :ts:cv:`proxy.config.http.cache.ignore_server_no_cache` in :file:"
"`records.config`. ::"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:473
msgid ""
"To configure Traffic Server to ignore server ``WWW-Authenticate`` headers:"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:476
msgid ""
"Edit :ts:cv:`proxy.config.http.cache.ignore_authentication` in :file:"
"`records.config`. ::"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:492
msgid "Not cache any HTTP objects. Refer to `Disabling HTTP Object Caching`_."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:494
msgid ""
"Cache *dynamic content*. That is, objects with URLs that end in ``.asp`` or "
"contain a question mark (``?``), semicolon (``;``), or ``cgi``. For more "
"information, refer to `Caching Dynamic Content`_."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:498
msgid ""
"Cache objects served in response to the ``Cookie:`` header. Refer to "
"`Caching Cookied Objects`_."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:501
msgid "Observe ``never-cache`` rules in :file:`cache.config`."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:506
msgid ""
"By default, Traffic Server caches all HTTP objects except those for which "
"you have set ``never-cache`` as :ref:`action rules <cache-config-format-"
"action>` in :file:`cache.config`. You can disable HTTP object caching so "
"that all HTTP objects are served directly from the origin server and never "
"cached, as detailed below."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:512
msgid "To disable HTTP object caching manually:"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:514
msgid ""
"Set :ts:cv:`proxy.config.http.enabled` to ``0`` in :file:`records."
"config`. ::"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:523
msgid ""
"A URL is considered dynamic if it ends in ``.asp`` or contains a question "
"mark (``?``), a semicolon (``;``), or ``cgi``. By default, Traffic Server "
"caches dynamic content. You can configure the system to ignore dynamic "
"looking content, although this is recommended only if the content is truly "
"dynamic, but fails to advertise so with appropriate ``Cache-Control`` "
"headers."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:530
msgid ""
"To configure Traffic Server's cache behaviour in regard to dynamic content:"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:533
msgid ""
"Edit :ts:cv:`proxy.config.http.cache.cache_urls_that_look_dynamic` in :file:"
"`records.config`. To disable caching, set the variable to ``0``, and to "
"explicitly permit caching use ``1``. ::"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:555
msgid "Not cache cookied content of any type."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:561
msgid "To configure how Traffic Server caches cookied content:"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:563
msgid ""
"Edit :ts:cv:`proxy.config.http.cache.cache_responses_to_cookies` in :file:"
"`records.config`."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:575
msgid "To force document caching:"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:587
msgid ""
"Some origin servers answer requests to the same URL with a variety of "
"objects. The content of these objects can vary widely, according to whether "
"a server delivers content for different languages, targets different "
"browsers with different presentation styles, or provides different document "
"formats (HTML, XML). Different versions of the same object are termed "
"*alternates* and are cached by Traffic Server based on ``Vary`` response "
"headers. You can specify additional request and response headers for "
"specific ``Content-Type`` values that Traffic Server will identify as "
"alternates for caching. You can also limit the number of alternate versions "
"of an object allowed in the cache."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:603
msgid "Edit the following variables in :file:`records.config`:"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:632
msgid "To alter the limit on the number of alternates:"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:634
msgid ""
"Edit :ts:cv:`proxy.config.cache.limits.http.max_alts` in :file:`records."
"config`. ::"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:645
msgid ""
"The *Congestion Control* option enables you to configure Traffic Server to "
"stop forwarding HTTP requests to origin servers when they become congested. "
"Traffic Server then sends the client a message to retry the congested "
"origin server later."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:650
msgid "To enable this option:"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:652
msgid ""
"Set :ts:cv:`proxy.config.http.congestion_control.enabled` to ``1`` in :file:"
"`records.config`. ::"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:657
msgid "Create rules in :file:`congestion.config` to specify:"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:659
msgid "Which origin servers Traffic Server tracks for congestion."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:661
msgid ""
"The timeouts Traffic Server uses, depending on whether a server is "
"congested."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:664
msgid ""
"The page Traffic Server sends to the client when a server becomes congested."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:667
msgid ""
"Whether Traffic Server tracks the origin servers by IP address or by "
"hostname."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:677
msgid ""
"By default, I/O operations are run at full speed, as fast as either Traffic "
"Server, the network, or the cache can support. This can be problematic for "
"large objects if the client side connection is significantly slower. In "
"such cases the content will be buffered in ram while waiting to be sent to "
"the client. This could potentially also happen for ``POST`` requests if the "
"client connection is fast and the origin server connection slow. If very "
"large objects are being used this can cause the memory usage of Traffic "
"Server to become `very large <https://issues.apache.org/jira/browse/"
"TS-1496>`_."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:710
msgid ":c:func:`TSHttpTxnConfigIntSet` key"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:712
msgid ":c:data:`TS_CONFIG_HTTP_FLOW_CONTROL_ENABLED`"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:713
msgid ":c:data:`TS_CONFIG_HTTP_FLOW_CONTROL_HIGH_WATER`"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:714
msgid ":c:data:`TS_CONFIG_HTTP_FLOW_CONTROL_LOW_WATER`"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:720
msgid ""
"If using :c:func:`TSHttpTxnConfigIntSet`, it must be called no later than :"
"c:data:`TS_HTTP_READ_RESPONSE_HDR_HOOK`."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:737
msgid ""
"When Traffic Server goes to fetch something from origin, and upon receiving "
"the response, any number of clients can be allowed to start serving the "
"partially filled cache object once background_fill_completed_threshold % of "
"the object has been received."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:742
msgid ""
"While some other HTTP proxies permit clients to begin reading the response "
"immediately upon the proxy receiving data from the origin server, ATS does "
"not begin allowing clients to read until after the complete HTTP response "
"headers have been read and processed. This is a side-effect of ATS making "
"no distinction between a cache refresh and a cold cache, which prevents "
"knowing whether a response is going to be cacheable."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:749
msgid ""
"As non-cacheable responses from an origin server are generally due to that "
"content being unique to different client requests, ATS will not enable read-"
"while-writer functionality until it has determined that it will be able to "
"cache the object."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:754
msgid ""
"The following settings must be made in :file:`records.config` to enable "
"read-while-writer functionality in ATS::"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:764
msgid ""
":ts:cv:`proxy.config.cache.enable_read_while_writer` being set to ``1`` "
"turns the feature on, as it is off (``0``) by default."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:767
msgid ""
"The background fill feature (both :ts:cv:`proxy.config.http."
"background_fill_active_timeout` and :ts:cv:`proxy.config.http."
"background_fill_completed_threshold`) should be allowed to kick in for "
"every possible request. This is necessary in the event the writer (the "
"first client session to request the object, which triggered ATS to contact "
"the origin server) goes away. Another client session needs to take over the "
"writer."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:775
msgid ""
"As such, you should set the background fill timeouts and threshold to zero; "
"this assures they never time out and are always allowed to kick in."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:778
msgid ""
"The :ts:cv:`proxy.config.cache.max_doc_size` should be unlimited (set to "
"0), since the object size may be unknown, and going over this limit would "
"cause a disconnect on the objects being served."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:782
msgid ""
"Once these are enabled, you have something that is very close, but not "
"quite the same, to Squid's Collapsed Forwarding."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:790
msgid ""
"Traffic Server can be set to attempt to revalidate an object before it "
"becomes stale in cache. :file:`records.config` contains the settings::"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:797
msgid ""
"For every request for an object that occurs :ts:cv:`proxy.config.http.cache."
"fuzz.time` before (in the example above, 240 seconds) the object is set to "
"become stale, there is a small chance (:ts:cv:`proxy.config.http.cache.fuzz."
"probability` == 0.5%) that the request will trigger a revalidation request "
"to the origin."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:805
msgid ""
"When revalidation occurs, the requested object is no longer available to be "
"served from cache. Subsequent requests for that object will be proxied to "
"the origin."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:809
msgid ""
"For objects getting a few requests per second, these settings would offer a "
"fairly low probability of revalidating the cached object before it becomes "
"stale. This feature is not typically necessary at those rates, though, "
"since odds are only one or a small number of connections would hit origin "
"upon the objects going stale."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:815
msgid ""
"Once request raise rise, the same ``fuzz.probability`` leads to a greater "
"chance the object may be revalidated before becoming stale. This can "
"prevent multiple clients simultaneously triggering contact with the origin "
"server under higher loads, as they would do if no fuzziness was employed "
"for revalidations."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:821
msgid ""
"These settings are also overridable by remap rules and via plugins, so can "
"be adjusted per request if necessary."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:824
msgid ""
"Finally, :ts:cv:`proxy.config.http.cache.fuzz.min_time` allows for "
"different time periods to evaluate the probability of revalidation for "
"small TTLs and large TTLs. Objects with small TTLs will start \"rolling the "
"revalidation dice\" near the ``fuzz.min_time``, while objects with large "
"TTLs would start at ``fuzz.time``."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:830
msgid ""
"A logarithmic like function between determines the revalidation evaluation "
"start time (which will be between ``fuzz.min_time`` and ``fuzz.time``). As "
"the object gets closer to expiring, the window start becomes more likely. "
"By default this setting is not enabled, but should be enabled anytime you "
"have objects with small TTLs. Note that this option predates overridable "
"configurations, so you can achieve something similar with a plugin or :file:"
"`remap.config` settings."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:838
msgid ""
"These configuration options are similar to Squid's refresh_stale_hit "
"configuration option."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:844
msgid ""
"The open read retry configurations attempt to reduce the number of "
"concurrent requests to the origin for a given object. While an object is "
"being fetched from the origin server, subsequent requests would wait :ts:cv:"
"`proxy.config.http.cache.open_read_retry_time` milliseconds before checking "
"if the object can be served from cache. If the object is still being "
"fetched, the subsequent requests will retry :ts:cv:`proxy.config.http.cache."
"max_open_read_retries` times. Thus, subsequent requests may wait a total of "
"(``max_open_read_retries`` x ``open_read_retry_time``) milliseconds before "
"establishing an origin connection of its own. For instance, if they are set "
"to ``5`` and ``10`` respectively, connections will wait up to 50ms for a "
"response to come back from origin from a previous request, until this "
"request is allowed through."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:859
msgid ""
"These settings are inappropriate when objects are uncacheable. In those "
"cases, requests for an object effectively become serialized. The subsequent "
"requests would await at least ``open_read_retry_time`` milliseconds before "
"being proxied to the origin."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:864
msgid ""
"It is advisable that this setting be used in conjunction with `Read While "
"Writer`_ for big (those that take longer than (``max_open_read_retries`` x "
"``open_read_retry_time``) milliseconds to transfer) cacheable objects. "
"Without the read-while-writer settings enabled, while the initial fetch is "
"ongoing, not only would subsequent requests be delayed by the maximum time, "
"but also, those requests would result in unnecessary requests to the origin "
"server."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:874
msgid "The configurations are (with defaults)::"
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:879
msgid ""
"The defaults are such that the feature is disabled and every connection is "
"allowed to go to origin without artificial delay. When enabled, you will "
"try ``max_open_read_retries`` times, each with an ``open_read_retry_time`` "
"timeout."
msgstr ""

#: ../../admin/http-proxy-caching.en.rst:601
msgid "To configure how Traffic Server caches alternates:"
msgstr ""

#~ msgid "Scheduling Updates to Local Cache Content"
#~ msgstr "ローカルキャッシュコンテンツの計画アップデート"

#~ msgid ""
#~ "Enable the scheduled update option and configure optional retry settings."
#~ msgstr ""
#~ "計画アップデートオプションの有効化とオプショナルなリトライ設定の指定"

#~ msgid "Configuring the Scheduled Update Option"
#~ msgstr "計画アップデートオプションの設定"

#~ msgid "To configure the scheduled update option"
#~ msgstr "計画アップデートオプションを設定するためには"

#~ msgid ""
#~ "Edit :file:`update.config` to enter a line in the file for each URL you "
#~ "want to update."
#~ msgstr ""
#~ ":file:`update.config` にアップデートしたい URL を一行毎に書いてください"

#~ msgid ":ts:cv:`proxy.config.update.enabled`"
#~ msgstr ":ts:cv:`proxy.config.update.enabled`"

#~ msgid ":ts:cv:`proxy.config.update.retry_count`"
#~ msgstr ":ts:cv:`proxy.config.update.retry_count`"

#~ msgid ":ts:cv:`proxy.config.update.retry_interval`"
#~ msgstr ":ts:cv:`proxy.config.update.retry_interval`"

#~ msgid ":ts:cv:`proxy.config.update.concurrent_updates`"
#~ msgstr ":ts:cv:`proxy.config.update.concurrent_updates`"

#~ msgid ""
#~ "When you enable the Force Immediate Update option, Traffic Server "
#~ "continually updates the URLs specified in :file:`update.config` until "
#~ "you disable the option. To disable the Force Immediate Update option, "
#~ "set :ts:cv:`proxy.config.update.force` to ``0`` (zero)."
#~ msgstr ""
#~ "強制即時アップデートオプションを有効にした場合、Traffic Server はこのオプ"
#~ "ションが無効化されるまで :file:`update.config` ファイルに指定された URL "
#~ "をアップデートし続けます。強制即時アップデートオプションを無効化するため"
#~ "には、 :ts:cv:`proxy.config.update.force` 変数を ``0`` (ゼロ) にしてくだ"
#~ "さい。"

#~ msgid ""
#~ "Web proxy caching enables you to store copies of frequently-accessed web "
#~ "objects (such as documents, images, and articles) and then serve this "
#~ "information to users on demand. It improves performance and frees up "
#~ "Internet bandwidth for other tasks."
#~ msgstr ""
#~ "ウェブプロキシーキャッシュは頻繁にアクセスされるウェブオブジェクト(ドキュ"
#~ "メントや画像、記事など)のコピーを保存し、ユーザーの求めに応じてこれらを配"
#~ "信することを可能にします。これはパフォーマンスを向上させ、インターネット"
#~ "の帯域を他のタスクのために空けます。"

#~ msgid ""
#~ "Internet users direct their requests to web servers all over the "
#~ "Internet. A caching server must act as a **web proxy server** so it can "
#~ "serve those requests. After a web proxy server receives requests for web "
#~ "objects, it either serves the requests or forwards them to the **origin "
#~ "server** (the web server that contains the original copy of the "
#~ "requested information). The Traffic Server proxy supports **explicit "
#~ "proxy caching**, in which the user's client software must be configured "
#~ "to send requests directly to the Traffic Server proxy. The following "
#~ "overview illustrates how Traffic Server serves a request."
#~ msgstr ""
#~ "インターネットユーザはインターネット上のウェブサーバーへリクエストを出し"
#~ "ます。キャッシュサーバーはこれらのリクエストを満たすために **ウェブプロキ"
#~ "シサーバー** として振る舞わなくてはなりません。ウェブプロキシーサーバーが"
#~ "ウェブオブジェクトへのリクエストを受け取った後は、そのリクエストを返す"
#~ "か、**オリジンサーバー** (リクエストされた情報のオリジナルコピーを持って"
#~ "いるウェブサーバー)へ転送します。Traffic Server プロキシーは **explicit "
#~ "proxy caching** をサポートしています。この際、ユーザーのクライアントソフ"
#~ "トが Traffic Server プロキシーへ直接リクエストを送るように設定されている"
#~ "必要があります。次のオーバービューは Traffic Server がどのようにリクエス"
#~ "トを返すかを描いています。"

#~ msgid ""
#~ "Using the object address, Traffic Server tries to locate the requested "
#~ "object in its object database (**cache**)."
#~ msgstr ""
#~ "オブジェクトのアドレスを用いて、Traffic Server はオブジェクトデータベース"
#~ "( **キャッシュ** )からリクエストされたオブジェクトを探します。"

#~ msgid ""
#~ "If the object is in the cache, then Traffic Server checks to see if the "
#~ "object is fresh enough to serve. If it is fresh, then Traffic Server "
#~ "serves it to the client as a **cache hit** (see the figure below)."
#~ msgstr ""
#~ "キャッシュにオブジェクトがある場合、Traffic Server はオブジェクトが提供す"
#~ "るのに十分新しいか確認します。新しい場合、Traffic Server は *キャッシュ"
#~ "ヒット* (下の図を見てください) としてクライアントにそれを提供します。"

#~ msgid ""
#~ "If the object is not in the cache (a **cache miss**) or if the server "
#~ "indicates the cached copy is no longer valid, then Traffic Server "
#~ "obtains the object from the origin server. The object is then "
#~ "simultaneously streamed to the client and the Traffic Server local cache "
#~ "(see the figure below). Subsequent requests for the object can be served "
#~ "faster because the object is retrieved directly from cache."
#~ msgstr ""
#~ "オブジェクトがキャッシュに無い場合 ( **キャッシュミス**) やサーバーが"
#~ "キャッシュしたコピーをもはや有効ではないと判断した場合、 Traffic Server "
#~ "はオリジンサーバーからオブジェクトを取得します。オブジェクトはクライアン"
#~ "トと Traffic Server のローカルキャッシュに同時に流されます。(下の図を見て"
#~ "ください) 続いて起こるオブジェクトへのリクエストはよりはやく提供すること"
#~ "ができます。それはオブジェクトがキャッシュから直接検索されるからです。"

#~ msgid ""
#~ "Caching is typically more complex than the preceding overview suggests. "
#~ "In particular, the overview does not discuss how Traffic Server ensures "
#~ "freshness, serves correct HTTP alternates, and treats requests for "
#~ "objects that cannot/should not be cached. The following sections discuss "
#~ "these issues in greater detail."
#~ msgstr ""
#~ "一般的にキャッシュは前述の概要で説明したものよりも複雑です。 詳しく述べる"
#~ "と、概要では Traffic Server がどのように新鮮さを保証し、正しい HTTP オブ"
#~ "ジェクトの代替を提供し、キャッシュできない/するべきではないオブジェクトへ"
#~ "のリクエストを扱うかについて説明されていませんでした。次の章はこれらのこ"
#~ "とについてとても詳しく説明します。"

#~ msgid ""
#~ "Traffic Server determines whether an HTTP object in the cache is fresh "
#~ "by:"
#~ msgstr ""
#~ "Traffic Server はキャッシュした HTTP オブジェクトが新しいかどうかを次のこ"
#~ "とによって決定します。"

#~ msgid ""
#~ "where *date* is the date in the object's server response header and "
#~ "*last_modified* is the date in the ``Last-Modified`` header. If there is "
#~ "no ``Last-Modified`` header, then Traffic Server uses the date the "
#~ "object was written to cache. The value ``0.10`` (10 percent) can be "
#~ "increased or reduced to better suit your needs (refer to `Modifying "
#~ "Aging Factor for Freshness Computations`_)."
#~ msgstr ""
#~ "この *date* はオブジェクトのサーバーのレスポンスヘッダーの日付で、"
#~ "*last_modified* は ``Last-Modified`` ヘッダーの日付です。 ``Last-"
#~ "Modified`` ヘッダーが無い場合、Traffic Server はオブジェクトがキャッシュ"
#~ "に書かれた日時を使用します。 ``0.10`` (10 %) という値は必要に応じて、増減"
#~ "することができます。 (詳しくは `新鮮さの計算のための期間要素の変更`_ を参"
#~ "照してください)"

#~ msgid ""
#~ "The computed freshness limit is bound by a minimum and maximum value - "
#~ "refer to `Setting Absolute Freshness Limits`_ for more information."
#~ msgstr ""
#~ "計算されたフレッシュネスリミットは最小値と最大値に紐づけられます。 - 詳細"
#~ "は `絶対フレッシュネスリミットの設定`_ を参照してください。"

#~ msgid ""
#~ "For HTTP objects that do not have ``Expires`` headers or do not have "
#~ "both ``Last-Modified`` and ``Date`` headers, Traffic Server uses a "
#~ "maximum and minimum freshness limit (refer to `Setting Absolute "
#~ "Freshness Limits`_)."
#~ msgstr ""
#~ "``Expires`` ヘッダーを持っていない、もしくは ``Last-Modified`` と "
#~ "``Date`` ヘッダーの両方をもっていない HTTP オブジェクトについて、Traffic "
#~ "Server はフレッシュネスリミットの最小値と最大値を使用します。( `絶対フ"
#~ "レッシュネスリミットの設定`_ を参照してください。)"

#~ msgid "**Checking revalidate rules in the** :file:`cache.config` **file**"
#~ msgstr ":file:`cache.config` **ファイル内の再確認ルールの確認**"

#~ msgid ""
#~ "Revalidate rules apply freshness limits to specific HTTP objects. You "
#~ "can set freshness limits for objects originating from particular domains "
#~ "or IP addresses, objects with URLs that contain specified regular "
#~ "expressions, objects requested by particular clients, and so on (refer "
#~ "to :file:`cache.config`)."
#~ msgstr ""
#~ "再検証ルールは特定の HTTP オブジェクトにフレッシュネスリミットを適用しま"
#~ "す。特定のドメインや IP アドレスから来たオブジェクト、特定の正規表現を含"
#~ "む URL を持つオブジェクトや特定のクライアントからリクエストされたオブジェ"
#~ "クトなどにフレッシュネスリミットを設定することができます。( :file:`cache."
#~ "config` を参照してください。)"

#~ msgid "To modify the aging factor for freshness computations"
#~ msgstr "新鮮さの計算のための期間の要素を変更するためには、"

#~ msgid "Setting absolute Freshness Limits"
#~ msgstr "絶対フレッシュネスリミットの設定"

#~ msgid ""
#~ "Some objects do not have ``Expires`` headers or do not have both ``Last-"
#~ "Modified`` and ``Date`` headers. To control how long these objects are "
#~ "considered fresh in the cache, specify an **absolute freshness limit**."
#~ msgstr ""
#~ "いくつかのオブジェクトは ``Expires`` ヘッダーを持っていない、もしくは "
#~ "``Last-Modified`` と ``Date`` ヘッダーの両方を持っていないことがありま"
#~ "す。これらのオブジェクトがキャッシュされてどの程度フレッシュであると考え"
#~ "られるか制御するために、 **絶対フレッシュネスリミット** があります。"

#~ msgid "To specify an absolute freshness limit"
#~ msgstr "絶対フレッシュネスリミットを明確にするために"

#~ msgid "Edit the variables"
#~ msgstr "次の変数を変更してください。"

#~ msgid ":ts:cv:`proxy.config.http.cache.heuristic_min_lifetime`"
#~ msgstr ":ts:cv:`proxy.config.http.cache.heuristic_min_lifetime`"

#~ msgid ":ts:cv:`proxy.config.http.cache.heuristic_max_lifetime`"
#~ msgstr ":ts:cv:`proxy.config.http.cache.heuristic_max_lifetime`"

#~ msgid "To configure Traffic Server to cache objects with specific headers"
#~ msgstr ""
#~ "特定のヘッダーを持つオブジェクトをキャッシュするように Traffic Server を"
#~ "設定するには"

#~ msgid ""
#~ "Change the value for :ts:cv:`proxy.config.http.cache.required_headers`."
#~ msgstr ""
#~ ":ts:cv:`proxy.config.http.cache.required_headers` の値を変更してくださ"
#~ "い。"

#~ msgid ""
#~ "Even though an object might be fresh in the cache, clients or servers "
#~ "often impose their own constraints that preclude retrieval of the object "
#~ "from the cache. For example, a client might request that a object *not* "
#~ "be retrieved from a cache, or if it does, then it cannot have been "
#~ "cached for more than 10 minutes. Traffic Server bases the servability of "
#~ "a cached object on ``Cache-Control`` headers that appear in both client "
#~ "requests and server responses. The following ``Cache-Control`` headers "
#~ "affect whether objects are served from cache:"
#~ msgstr ""
#~ "キャッシュしたあるオブジェクトが新鮮だと思われる場合であっても、クライア"
#~ "ントやサーバーはキャッシュからのオブジェクトの読み出しを妨害するようにた"
#~ "びたび制限を課します。例えば、あるクライアントがキャッシュから復旧するべ"
#~ "き *ではない* オブジェクトへリクエストするかもしれません。また、それをし"
#~ "た場合、10 分以上はキャッシュすることはできません。 Traffic Server は"
#~ "キャッシュしたオブジェクトの提供可能性をクライアントのリクエストとサー"
#~ "バーのレスポンス両方に現れる ``Cache-Control`` ヘッダーを根拠に決定してい"
#~ "ます。次のような ``Cache-Control`` ヘッダーはキャッシュからオブジェクトを"
#~ "提供するかどうかに影響します。"

#~ msgid ""
#~ "The ``no-cache`` header, sent by clients, tells Traffic Server that it "
#~ "should not serve any objects directly from the cache; therefore, Traffic "
#~ "Server will always obtain the object from the origin server. You can "
#~ "configure Traffic Server to ignore client ``no-cache`` headers - refer "
#~ "to `Configuring Traffic Server to Ignore Client no-cache Headers`_ for "
#~ "more information."
#~ msgstr ""
#~ "クライアントから送られる ``no-cache`` ヘッダーはどんなオブジェクトも"
#~ "キャッシュから直接返すべきではないということを Traffic Server に示しま"
#~ "す。従って、Traffic Server は常にオリジンサーバーからオブジェクトを取得し"
#~ "ます。 Traffic Server をクライアントからの ``no-cache`` ヘッダーを無視す"
#~ "るように設定することもできます。詳細は `クライアントの no-cache ヘッダー"
#~ "を無視する Traffic Server の設定`_ を参照してください。"

#~ msgid ""
#~ "The ``max-age`` header, sent by servers, is compared to the object age. "
#~ "If the age is less than ``max-age``, then the object is fresh and can be "
#~ "served."
#~ msgstr ""
#~ "サーバーから送られる ``max-age`` ヘッダーはオブジェクトのキャッシュされて"
#~ "いる時間と比較されます。この時間が ``max-age`` よりも少ない場合、オブジェ"
#~ "クトはフレッシュであり配信されます。"

#~ msgid ""
#~ "The ``min-fresh`` header, sent by clients, is an **acceptable freshness "
#~ "tolerance**. This means that the client wants the object to be at least "
#~ "this fresh. Unless a cached object remains fresh at least this long in "
#~ "the future, it is revalidated."
#~ msgstr ""
#~ "クライアントからの ``min-fresh`` ヘッダーは **受け入れることが許容できる"
#~ "新鮮さ** です。これはクライアントが少なくとも指定された程度新鮮であること"
#~ "を望んでいるということを意味します。将来、キャッシュされたオブジェクトが"
#~ "この長さの新鮮さを失った場合、再検証されます。"

#~ msgid ""
#~ "Traffic Server applies ``Cache-Control`` servability criteria "
#~ "***after*** HTTP freshness criteria. For example, an object might be "
#~ "considered fresh but will not be served if its age is greater than its "
#~ "``max-age``."
#~ msgstr ""
#~ "Traffic Server は ``Cache-Control`` を HTTP の新鮮さの基準の ***後に*** "
#~ "配信可能性の基準に適用します。例えば、あるオブジェクトが新鮮だと考えられ"
#~ "る場合でも、経過時間が ``max-age`` よりも大きいければ、それは配信されませ"
#~ "ん。"

#~ msgid ""
#~ "When a client requests an HTTP object that is stale in the cache, "
#~ "Traffic Server revalidates the object. A **revalidation** is a query to "
#~ "the origin server to check if the object is unchanged. The result of a "
#~ "revalidation is one of the following:"
#~ msgstr ""
#~ "クライアントがキャッシュの中で新鮮ではなくなった HTTP オブジェクトをリク"
#~ "エストした際、Traffic Server はそのオブジェクトを再検証します。**再検証"
#~ "** はオリジンサーバーへオブジェクトが変更されているかどうかを確認する問い"
#~ "合わせです。再検証の結果は次のいずれかです。"

#~ msgid ""
#~ "Traffic Server considers all HTTP objects in the cache to be stale: "
#~ "always revalidate HTTP objects in the cache with the origin server."
#~ msgstr ""
#~ "Traffic Server はキャッシュしている全ての HTTP オブジェクトが新鮮ではない"
#~ "と考えます。つまり、常にキャッシュの中の HTTP オブジェクトをオリジンサー"
#~ "バーへ再検証します。"

#~ msgid ""
#~ "Traffic Server considers all HTTP objects in the cache to be fresh: "
#~ "never revalidate HTTP objects in the cache with the origin server."
#~ msgstr ""
#~ "Traffic Server はキャッシュしている全ての HTTP オブジェクトを新鮮であると"
#~ "考えます。つまり、オリジンサーバーへ HTTP オブジェクトを再検証することは"
#~ "ありません。"

#~ msgid ""
#~ "Traffic Server considers all HTTP objects without ``Expires`` or ``Cache-"
#~ "control`` headers to be stale: revalidate all HTTP objects without "
#~ "``Expires`` or ``Cache-Control`` headers."
#~ msgstr ""
#~ "Traffic Server は ``Expires`` や ``Cache-Control`` ヘッダーを持っていな"
#~ "い HTTP オブジェクトを新鮮ではないと考えます。つまり、常に ``Expires`` "
#~ "や ``Cache-Control`` ヘッダーのない HTTP オブジェクトを再検証します。"

#~ msgid "Edit the following variable in :file:`records.config`"
#~ msgstr ":file:`records.config` の次の変数を変更してください。"

#~ msgid ":ts:cv:`proxy.config.http.cache.when_to_revalidate`"
#~ msgstr ":ts:cv:`proxy.config.http.cache.when_to_revalidate`"

#~ msgid ""
#~ "To further increase performance and to ensure that HTTP objects are "
#~ "fresh in the cache, you can use the **Scheduled Update** option. This "
#~ "configures Traffic Server to load specific objects into the cache at "
#~ "scheduled times. You might find this especially beneficial in a reverse "
#~ "proxy setup, where you can *preload* content you anticipate will be in "
#~ "demand."
#~ msgstr ""
#~ "パフォーマンスをはるかに向上させるため、またキャッシュしている HTTP オブ"
#~ "ジェクトが新鮮であることを確実にするために、**計画アップデート** オプショ"
#~ "ンを使うことができます。これは特定のオブジェクトをスケジュールされた時間"
#~ "にキャッシュに読み込むように Traffic Server を設定します。リバースプロキ"
#~ "シーをセットアップしている際に、 負荷が心配されるコンテンツを *事前に読み"
#~ "込む* ことができるという点で特に役に立つことに気づくかもしれません。"

#~ msgid ""
#~ "To use the Scheduled Update option, you must perform the following tasks."
#~ msgstr ""
#~ "計画的アップデートオプションを使うためには次のタスクを行う必要がありま"
#~ "す。"

#~ msgid ""
#~ "Specify the list of URLs that contain the objects you want to schedule "
#~ "for update,"
#~ msgstr ""
#~ "スケジュール通りにアップデートしたいオブジェクトを含む URL のリスト"

#~ msgid "the time the update should take place,"
#~ msgstr "アップデートが実行されるべき時間"

#~ msgid "and the recursion depth for the URL."
#~ msgstr "URL の再帰する深さを指定"

#~ msgid ""
#~ "Traffic Server uses the information you specify to determine URLs for "
#~ "which it is responsible. For each URL, Traffic Server derives all "
#~ "recursive URLs (if applicable) and then generates a unique URL list. "
#~ "Using this list, Traffic Server initiates an HTTP ``GET`` for each "
#~ "unaccessed URL. It ensures that it remains within the user-defined "
#~ "limits for HTTP concurrency at any given time. The system logs the "
#~ "completion of all HTTP ``GET`` operations so you can monitor the "
#~ "performance of this feature."
#~ msgstr ""
#~ "Traffic Server は責任を持つ URL を決定するために、指定された情報を使いま"
#~ "す。各 URL に対して Traffic Server は (適用可能であれば) 全ての再帰的な "
#~ "URL を作成し、ユニークな URL リストを生成します。このリストをもとに、"
#~ "Traffic Server はまだアクセスされていない各 URL に対して HTTP ``GET`` リ"
#~ "クエストを開始します。このリクエストは常に ユーザーが定義した HTTP の並列"
#~ "度の範囲に収まることが保証されています。システムは全ての HTTP ``GET`` オ"
#~ "ペレーションの完了を記録します。よって、この機能のパフォーマンスを監視す"
#~ "ることができます。"

#~ msgid ""
#~ "Traffic Server also provides a **Force Immediate Update** option that "
#~ "enables you to update URLs immediately without waiting for the specified "
#~ "update time to occur. You can use this option to test your scheduled "
#~ "update configuration (refer to `Forcing an Immediate Update`_)."
#~ msgstr ""
#~ "Traffic Server は **強制即時アップデート** オプションも提供します。これ"
#~ "は URL を指定されたアップデート時間になるまで待つことなく、すぐにアップ"
#~ "デートすることを可能にします。このオプションを計画アップデートの設定をテ"
#~ "ストするために使うことができます。( `即時アップデートの強制`_ を参照して"
#~ "ください)"

#~ msgid "Edit the following variables"
#~ msgstr "次の変数を変更してください。"

#~ msgid "Forcing an Immediate Update"
#~ msgstr "即時アップデートの強制"

#~ msgid ""
#~ "Traffic Server provides a **Force Immediate Update** option that enables "
#~ "you to immediately verify the URLs listed in :file:`update.config`. The "
#~ "Force Immediate Update option disregards the offset hour and interval "
#~ "set in :file:`update.config` and immediately updates the URLs listed."
#~ msgstr ""
#~ "Traffic Server は **強制即時アップデート** オプションを提供しています。こ"
#~ "れは :file:`update.config` ファイルにリストされた URL を即時に検証す るこ"
#~ "とを可能にします。強制即時アップデートオプションは :file:`update.config` "
#~ "ファイルに設定されたオフセット時間と間隔を無視し、リストされた URL を即時"
#~ "的にアップデートします。"

#~ msgid "To configure the Force Immediate Update option"
#~ msgstr "強制即時アップデートオプション設定"

#~ msgid ":ts:cv:`proxy.config.update.force`"
#~ msgstr ":ts:cv:`proxy.config.update.force`"

#~ msgid "Make sure :ts:cv:`proxy.config.update.enabled` is set to 1."
#~ msgstr ""
#~ ":ts:cv:`proxy.config.update.enabled` に 1 が設定されていることを確認して"
#~ "ください。"

#~ msgid "To configure Traffic Server to accept ``PUSH`` requests"
#~ msgstr ""
#~ "Traffic Server が ``PUSH`` リクエストを受け入れるように設定するには"

#~ msgid "Edit :file:`ip_allow.config` to allow ``PUSH``."
#~ msgstr ":file:`ip_allow.config` を変更して ``PUSH`` を許可してください。"

#~ msgid ""
#~ "Edit the following variable in :file:`records.config`, enable the "
#~ "push_method."
#~ msgstr ""
#~ ":file:`records.config` の次の変数を編集して、push_method を有効にしてくだ"
#~ "さい。"

#~ msgid ":ts:cv:`proxy.config.http.push_method_enabled`"
#~ msgstr ":ts:cv:`proxy.config.http.push_method_enabled`"

#~ msgid ""
#~ "Your header must include ``Content-length`` - ``Content-length`` must "
#~ "include both ``header`` and ``body byte count``."
#~ msgstr ""
#~ "ヘッダーは ``Contetnt-length`` を含んでいる必要があります - ``Contetn-"
#~ "length`` は ``header`` と ``body byte count`` の両方を含む必 要がありま"
#~ "す。"

#~ msgid ""
#~ "There is a perl script for pushing, :program:`tspush`, which can help "
#~ "you understanding how to write scripts for pushing content yourself."
#~ msgstr ""
#~ "プッシュするための perl スクリプトがあります。:program:`tspush` です。こ"
#~ "れはコンテンツをプッシュするためのスクリプトの書き方を理解することに役立"
#~ "ちます。"

#~ msgid ""
#~ "The **Cache Pinning Option** configures Traffic Server to keep certain "
#~ "HTTP objects in the cache for a specified time. You can use this option "
#~ "to ensure that the most popular objects are in cache when needed and to "
#~ "prevent Traffic Server from deleting important objects. Traffic Server "
#~ "observes ``Cache-Control`` headers and pins an object in the cache only "
#~ "if it is indeed cacheable."
#~ msgstr ""
#~ "**キャッシュのピン留めオプション** は特定の時間の間 HTTP オブジェクトを"
#~ "キャッシュに確実に入れておくように Traffic Server を設定します。最もポ"
#~ "ピュラーなオブジェクトが必要とされるときにキャッシュされていることと、 "
#~ "Traffic Server が重要なオブジェクトを削除することを防ぐことを確実にしたい"
#~ "際にこのオプションが使えます。Traffic Server は ``Cache-Control`` ヘッ"
#~ "ダーを監視し、本当にキャッシュ可能な場合にオブジェクトをキャッシュに留め"
#~ "ます。"

#~ msgid "To set cache pinning rules"
#~ msgstr "キャッシュを留めるルールを設定するためには"

#~ msgid "Make sure the following variable in :file:`records.config` is set"
#~ msgstr ""
#~ ":file:`records.config` の次の変数がセットされていることを確認してくださ"
#~ "い。"

#~ msgid ":ts:cv:`proxy.config.cache.permit.pinning`"
#~ msgstr ":ts:cv:`proxy.config.cache.permit.pinning`"

#~ msgid "To Cache or Not to Cache?"
#~ msgstr "キャッシュするかキャッシュしないか?"

#~ msgid ""
#~ "By default, Traffic Server does *not* cache objects with the following "
#~ "**request headers**:"
#~ msgstr ""
#~ "デフォルトではTraffic Server は次の **リクエストヘッダー** を持つオブジェ"
#~ "クトをキャッシュ *しません* 。"

#~ msgid "``Authorization``: header"
#~ msgstr "``Authorization``: ヘッダー"

#~ msgid "``Cache-Control: no-store`` header"
#~ msgstr "``Cache-Control: no-store`` ヘッダー"

#~ msgid "``Cache-Control: no-cache`` header"
#~ msgstr "``Cache-Control: no-cache`` ヘッダー"

#~ msgid ""
#~ "To configure Traffic Server to ignore the ``Cache-Control: no-cache`` "
#~ "header, refer to `Configuring Traffic Server to Ignore Client no-cache "
#~ "Headers`_"
#~ msgstr ""
#~ "``Cache-Control: no-cache`` ヘッダーを無視するように Traffic Server を設"
#~ "定するには `クライアントの no-cache ヘッダーを無視する Traffic Server の"
#~ "設定`_ を参照してください。"

#~ msgid "``Cookie``: header (for text objects)"
#~ msgstr "``Cookie``: ヘッダー (テキストオブジェクト用)"

#~ msgid "To configure Traffic Server to ignore client ``no-cache`` headers"
#~ msgstr ""
#~ "``no-cache`` ヘッダーを無視するように Traffic Server を設定するには"

#~ msgid ":ts:cv:`proxy.config.http.cache.ignore_client_no_cache`"
#~ msgstr ":ts:cv:`proxy.config.http.cache.ignore_client_no_cache`"

#~ msgid ""
#~ "By default, Traffic Server does *not* cache objects with the following "
#~ "**response headers**:"
#~ msgstr ""
#~ "デフォルトでは Traffic Server は次の **レスポンスヘッダー** を持つような"
#~ "オブジェクトをキャッシュ *しません*。"

#~ msgid "``Cache-Control: private`` header"
#~ msgstr "``Cache-Control: private`` ヘッダー"

#~ msgid "``WWW-Authenticate``: header"
#~ msgstr "``WWW-Authenticate``: ヘッダー"

#~ msgid "``Set-Cookie``: header"
#~ msgstr "``Set-Cookie``: ヘッダー"

#~ msgid "``Cache-Control: no-cache`` headers"
#~ msgstr "``Cache-Control: no-cache`` ヘッダー"

#~ msgid "``Expires``: header with value of 0 (zero) or a past date"
#~ msgstr "値が 0 (ゼロ)もしくは過去の日付の ``Expires`` ヘッダー"

#~ msgid "To configure Traffic Server to ignore server ``no-cache`` headers"
#~ msgstr ""
#~ "サーバーの ``no-cache`` ヘッダーを無視するように Traffic Server を設定す"
#~ "るには"

#~ msgid ""
#~ "Edit the variable :ts:cv:`proxy.config.http.cache.ignore_server_no_cache`"
#~ msgstr ""
#~ ":ts:cv:`proxy.config.http.cache.ignore_server_no_cache` 変数を変更してく"
#~ "ださい。"

#~ msgid ""
#~ "To configure Traffic Server to ignore server ``WWW-Authenticate`` headers"
#~ msgstr ""
#~ "``WWW-Authenticate`` ヘッダーを無視するように Traffic Server を設定するに"
#~ "は"

#~ msgid ""
#~ "Edit the variable :ts:cv:`proxy.config.http.cache.ignore_authentication`"
#~ msgstr ""
#~ ":ts:cv:`proxy.config.http.cache.ignore_authentication` 変数を変更してくだ"
#~ "さい。"

#~ msgid ""
#~ "*Not* cache any HTTP objects (refer to `Disabling HTTP Object Caching`_)."
#~ msgstr ""
#~ "どんな HTTP オブジェクトもキャッシュ *しない* ( `HTTP オブジェクトキャッ"
#~ "シュの無効化`_ 参照)"

#~ msgid ""
#~ "Cache **dynamic content** - that is, objects with URLs that end in ``."
#~ "asp`` or contain a question mark (``?``), semicolon (**``;``**), or "
#~ "**``cgi``**. For more information, refer to `Caching Dynamic Content`_."
#~ msgstr ""
#~ "**動的コンテンツ** をキャッシュする - ``.asp`` で終わったり、クエスチョン"
#~ "マーク (``?``)、セミコロン (``;``) や ``cgi`` を含んでいたりする URL のオ"
#~ "ブジェクト。より詳しくは `動的コンテンツのキャッシュ`_ を参照してくださ"
#~ "い。"

#~ msgid ""
#~ "Cache objects served in response to the ``Cookie:`` header (refer to "
#~ "`Caching Cookied Objects`_."
#~ msgstr ""
#~ "``Cookie:`` ヘッダーに対して返されるオブジェクトをキャッシュする ( `クッ"
#~ "キーオブジェクトのキャッシュ`_ 参照)"

#~ msgid "Observe ``never-cache`` rules in the :file:`cache.config` file."
#~ msgstr ":file:`cache.config` ファイルの ``never-cache`` ルールに従う"

#~ msgid ""
#~ "By default, Traffic Server caches all HTTP objects except those for "
#~ "which you have set ``never-cache`` as :ref:`action rules <cache-config-"
#~ "format-action>` in the :file:`cache.config` file. You can disable HTTP "
#~ "object caching so that all HTTP objects are served directly from the "
#~ "origin server and never cached, as detailed below."
#~ msgstr ""
#~ "デフォルトでは Traffic Server は :file:`cache.config` ファイルに設定した "
#~ "``never-cache`` :ref:`アクションルール <cache-config-format-action>` を除"
#~ "く全ての HTTP オブジェクトをキャッシュします。後述するように　HTTP オブ"
#~ "ジェクトがオリジンサーバーから直接配信され、決してキャッシュされな いよう"
#~ "に HTTP オブジェクトのキャッシュを無効化することができます。"

#~ msgid "To disable HTTP object caching manually"
#~ msgstr "HTTP オブジェクトを手動で無効化するには"

#~ msgid "Set the variable :ts:cv:`proxy.config.http.enabled` to ``0``."
#~ msgstr ""
#~ ":ts:cv:`proxy.config.http.enabled` 変数に ``0`` を設定してください。."

#~ msgid ""
#~ "A URL is considered **dynamic** if it ends in **``.asp``** or contains a "
#~ "question mark (``?``), a semicolon (``;``), or ``cgi``. By default, "
#~ "Traffic Server caches dynamic content. You can configure the system to "
#~ "ignore dyanamic looking content, although this is recommended only if "
#~ "the content is *truely* dyanamic, but fails to advertise so with "
#~ "appropriate ``Cache-Control`` headers."
#~ msgstr ""
#~ "``.asp`` で終わったり、クエスチョンマーク (``?``)、セミコロン (``;``) や "
#~ "``cgi`` を含んでいたりする URL  は **動的** であると考えられます。デフォ"
#~ "ルトでは Traffic Server は動的コンテンツをキャッシュします。コンテンツが "
#~ "*本当に* 動的である場合にだけ推奨されますが、適切な ``Cache-Control`` "
#~ "ヘッダーによって伝えることができないとき、動的だと思われるコンテンツを無"
#~ "視するようにシステムを設定することができます。"

#~ msgid ""
#~ "To configure Traffic Server's cache behaviour in regard to dynamic "
#~ "content"
#~ msgstr "動的コンテンツに配慮した Traffic Server の振る舞いを設定するには"

#~ msgid ":ts:cv:`proxy.config.http.cache.cache_urls_that_look_dynamic`"
#~ msgstr ":ts:cv:`proxy.config.http.cache.cache_urls_that_look_dynamic`"

#~ msgid "*Not* cache cookied content of any type."
#~ msgstr "クッキーを含む全てのコンテンツをキャッシュ *しない*"

#~ msgid "To configure how Traffic Server caches cookied content"
#~ msgstr ""
#~ "クッキーを含むコンテンツをどのようにキャッシュするか Traffic Server を設"
#~ "定するには"

#~ msgid ""
#~ "Edit the variable :ts:cv:`proxy.config.http.cache."
#~ "cache_responses_to_cookies`"
#~ msgstr ""
#~ ":ts:cv:`proxy.config.http.cache.cache_responses_to_cookies` 変数を変更し"
#~ "てください。"

#~ msgid "To force document caching"
#~ msgstr "ドキュメントを強制的にキャッシュするには"

#~ msgid ""
#~ "Some origin servers answer requests to the same URL with a variety of "
#~ "objects. The content of these objects can vary widely, according to "
#~ "whether a server delivers content for different languages, targets "
#~ "different browsers with different presentation styles, or provides "
#~ "different document formats (HTML, XML). Different versions of the same "
#~ "object are termed **alternates** and are cached by Traffic Server based "
#~ "on ``Vary`` response headers. You can specify additional request and "
#~ "response headers for specific ``Content-Type``\\s that Traffic Server "
#~ "will identify as alternates for caching. You can also limit the number "
#~ "of alternate versions of an object allowed in the cache."
#~ msgstr ""
#~ "いくつかの同一の URL へ複数のオブジェクトを回答するオリジンサーバーもあり"
#~ "ます。これらのオブジェクトのコンテンツはサーバーが異なる言語ごとにコンテ"
#~ "ンツを配信したり、異なるブラウザ毎にプレゼンテーションスタイルを用意して"
#~ "いたり、異なるドキュメントフォーマット(HTML, XML) を提供しているか等によ"
#~ "り、多岐にわたります。同一オブジェクトの異なるバージョンは **代替** と呼"
#~ "ばれ、``Vary`` レスポンスヘッダーに基づいて Traffic Server にキャッシュさ"
#~ "れます。Traffic Server がキャッシュする代替を判別する特別な ``Content-"
#~ "Type`` をリクエストやレスポンスヘッダに追加することができます。キャッシュ"
#~ "する代替バージョンの数を制限することもできます。"

#~ msgid ""
#~ "To configure how Traffic Server caches alternates, follow the steps below"
#~ msgstr ""
#~ "Traffic Server が代替をキャッシュするように設定するには、次のステップに"
#~ "従ってください。"

#~ msgid "To limit the number of alternates"
#~ msgstr "代替の数を制限するには"

#~ msgid "Edit the variable :ts:cv:`proxy.config.cache.limits.http.max_alts`"
#~ msgstr ""
#~ ":ts:cv:`proxy.config.cache.limits.http.max_alts` 変数を変更してください。"

#~ msgid ""
#~ "The **Congestion Control** option enables you to configure Traffic "
#~ "Server to stop forwarding HTTP requests to origin servers when they "
#~ "become congested. Traffic Server then sends the client a message to "
#~ "retry the congested origin server later."
#~ msgstr ""
#~ "**輻輳制御** オプションはオリジンサーバーが混雑しているときに Traffic "
#~ "Server が HTTP リクエストを転送することを止めることを可能にします。"
#~ "Traffic Server はその後、混雑してるオリジンサーバーに後でリトライするメッ"
#~ "セージをクライアントに送ります。"

#~ msgid ""
#~ "To use the **Congestion Control** option, you must perform the following "
#~ "tasks:"
#~ msgstr "**輻輳制御** オプションを使うには、次のタスクを実行してください。"

#~ msgid ""
#~ "Set the variable :ts:cv:`proxy.config.http.congestion_control.enabled` "
#~ "to ``1``"
#~ msgstr ""
#~ ":ts:cv:`proxy.config.http.congestion_control.enabled` 変数を ``1`` にセッ"
#~ "トして下さい。"

#~ msgid "Create rules in the :file:`congestion.config` file to specify:"
#~ msgstr ""
#~ "ルールを作成して :file:`congestion.config` ファイルに次のように記述してく"
#~ "ださい。"

#~ msgid "which origin servers Traffic Server tracks for congestion"
#~ msgstr "混雑しているか Traffic Server が追跡するオリジンサーバー"

#~ msgid ""
#~ "the timeouts Traffic Server uses, depending on whether a server is "
#~ "congested"
#~ msgstr ""
#~ "サーバーが混雑していると判定するために Traffic Sever が使用するタイムアウ"
#~ "ト値"

#~ msgid ""
#~ "the page Traffic Server sends to the client when a server becomes "
#~ "congested"
#~ msgstr "サーバー混雑時に Traffic Server がクライアントに送るページ"

#~ msgid ""
#~ "if Traffic Server tracks the origin servers per IP address or per "
#~ "hostname"
#~ msgstr ""
#~ "Traffic Server が IP アドレス毎に追跡するか、ホストネーム毎に追跡するかど"
#~ "うか"

#~ msgid ""
#~ "By default I/O operations are run at full speed, as fast as either "
#~ "Traffic Server, the network, or the cache can go. This can be "
#~ "problematic for large objects if the client side connection is "
#~ "significantly slower. In such cases the content will be buffered in ram "
#~ "while waiting to be sent to the client. This could potentially also "
#~ "happen for ``POST`` requests if the client connection is fast and the "
#~ "origin server connection slow. If very large objects are being used this "
#~ "can cause the memory usage of Traffic Server to become `very large "
#~ "<https://issues.apache.org/jira/browse/TS-1496>`_."
#~ msgstr ""
#~ "デフォルトでは I/O オペレーションは Traffic Server やネットワークやキャッ"
#~ "シュが実行できる限り速くフルスピードで実行されます。これはクライアント側"
#~ "のコネクションが遅い場合に、大きなオブジェクトにとって問題になる可能性が"
#~ "あります。このような場合、クライアントに送られるのを待っている間、コンテ"
#~ "ンツはメモリにバッファーされます。これはクライアントのコネクションが早"
#~ "く、オリジンサーバーのコネクションが遅い場合に ``POST`` リクエストでも発"
#~ "生し得ます。とても大きなオブジェクトが使われているとこれは Traffic "
#~ "Server のメモリ使用量がとても大きくなる原因になり得ます。 `very large "
#~ "<https://issues.apache.org/jira/browse/TS-1496>`_"

#~ msgid "`TSHttpTxnConfigIntSet` key"
#~ msgstr "`TSHttpTxnConfigIntSet` キー"

#~ msgid "`TS_CONFIG_HTTP_FLOW_CONTROL_ENABLED`"
#~ msgstr "`TS_CONFIG_HTTP_FLOW_CONTROL_ENABLED`"

#~ msgid "`TS_CONFIG_HTTP_FLOW_CONTROL_HIGH_WATER`"
#~ msgstr "`TS_CONFIG_HTTP_FLOW_CONTROL_HIGH_WATER`"

#~ msgid "`TS_CONFIG_HTTP_FLOW_CONTROL_LOW_WATER`"
#~ msgstr "`TS_CONFIG_HTTP_FLOW_CONTROL_LOW_WATER`"

#~ msgid ""
#~ "When Traffic Server goes to fetch something from origin, and upon "
#~ "receiving the response, any number of clients can be allowed to start "
#~ "serving the partially filled cache object once "
#~ "background_fill_completed_threshold % of the object has been received. "
#~ "The difference is that Squid allows this as soon as it goes to origin, "
#~ "whereas ATS can not do it until we get the complete response header. The "
#~ "reason for this is that we make no distinction between cache refresh, "
#~ "and cold cache, so we have no way to know if a response is going to be "
#~ "cacheable, and therefore allow read-while-writer functionality."
#~ msgstr ""
#~ "Traffic Server がオリジンからオブジェクトをフェッチしに行くとき、そしてレ"
#~ "スポンスを受け取るとき、受け取ったオブジェクトの "
#~ "background_fill_completed_threshold % が満たされた部分的キャッシュオブ"
#~ "ジェクトを配信することがどんな数のクライアントにも許されています。違いは "
#~ "Squid はオリジンに行ったすぐ後で許可していますが、ATS は完全なレスポンス"
#~ "ヘッダーを受け取るまでできないことです。この理由はキャッシュリフレッシュ"
#~ "とコールドキャッシュの間で差異を作りたくないからです。レスポンスがキャッ"
#~ "シュ可能なものか知る方法がないので、read-while-writer 機能を許可していま"
#~ "す。"

#~ msgid "The configurations necessary to enable this in ATS are:"
#~ msgstr "ATS でこれを有効化する為に必要な設定は"

#~ msgid ""
#~ "CONFIG :ts:cv:`proxy.config.cache.enable_read_while_writer` ``INT 1``"
#~ msgstr ""
#~ "CONFIG :ts:cv:`proxy.config.cache.enable_read_while_writer` ``INT 1``"

#~ msgid ""
#~ "CONFIG :ts:cv:`proxy.config.http.background_fill_active_timeout` ``INT "
#~ "0``"
#~ msgstr ""
#~ "CONFIG :ts:cv:`proxy.config.http.background_fill_active_timeout` ``INT "
#~ "0``"

#~ msgid ""
#~ "CONFIG :ts:cv:`proxy.config.http.background_fill_completed_threshold` "
#~ "``FLOAT 0.000000``"
#~ msgstr ""
#~ "CONFIG :ts:cv:`proxy.config.http.background_fill_completed_threshold` "
#~ "``FLOAT 0.000000``"

#~ msgid "CONFIG :ts:cv:`proxy.config.cache.max_doc_size` ``INT 0``"
#~ msgstr "CONFIG :ts:cv:`proxy.config.cache.max_doc_size` ``INT 0``"

#~ msgid ""
#~ "enable_read_while_writer turns the feature on. It's off (0) by default"
#~ msgstr ""
#~ "enable_read_while_writer は機能を on にします。デフォルトでは off (0) で"
#~ "す。"

#~ msgid ""
#~ "The background fill feature should be allowed to kick in for every "
#~ "possible request. This is necessary, in case the writer (\"first client "
#~ "session\") goes away, someone needs to take over the session. Hence, you "
#~ "should set the background fill timeouts and threshold to zero; this "
#~ "assures they never times out and always is allowed to kick in."
#~ msgstr ""
#~ "バックグラウンドフィル機能は全てのあり得るリクエストでキックされることが"
#~ "許可されているべきです。これは重要で、writer (\"最初のクライアントセッ"
#~ "ション\") が出て行った場合、誰かがセッションを引継ぐ必要があります。した"
#~ "がって、バックグラウンドフィルタイムアウトを設定し、境界点をゼロにするべ"
#~ "きです。これは彼らを安心させます。タイムアウトせずに、キックインすること"
#~ "を常に許可されています。"

#~ msgid ""
#~ "The proxy.config.cache.max_doc_size should be unlimited (set to 0), "
#~ "since the object size may be unknown, and going over this limit would "
#~ "cause a disconnect on the objects being served."
#~ msgstr ""
#~ "proxy.config.cache.max_doc_size は無制限(0)に設定されているべきです。オブ"
#~ "ジェクトサイズは分からないので。この制限は配信されているオブジェクトのコ"
#~ "ネクションの切断の原因になるかもしれません。"

#~ msgid ""
#~ "Once all this enabled, you have something that is very close, but not "
#~ "quite the same, as Squid's Collapsed Forwarding."
#~ msgstr ""
#~ "一度これら全てが有効化されると、Squid の Collapesd Forwarding にとても近"
#~ "いが異なるものができます。"

#~ msgid ""
#~ "Traffic Server can be set to attempt to revalidate an object before it "
#~ "becomes stale in cache. :file:`records.config` contains the settings:"
#~ msgstr ""
#~ "Traffic Server はキャッシュが新鮮でなくなる前に、オブジェクトの再検証を試"
#~ "みるように設定することもできます。:file:`records.config` に次の設定があり"
#~ "ます。"

#~ msgid "CONFIG :ts:cv:`proxy.config.http.cache.fuzz.time` ``INT 240``"
#~ msgstr "CONFIG :ts:cv:`proxy.config.http.cache.fuzz.time` ``INT 240``"

#~ msgid "CONFIG :ts:cv:`proxy.config.http.cache.fuzz.min_time` ``INT 0``"
#~ msgstr "CONFIG :ts:cv:`proxy.config.http.cache.fuzz.min_time` ``INT 0``"

#~ msgid ""
#~ "CONFIG :ts:cv:`proxy.config.http.cache.fuzz.probability` ``FLOAT 0.005``"
#~ msgstr ""
#~ "CONFIG :ts:cv:`proxy.config.http.cache.fuzz.probability` ``FLOAT 0.005``"

#~ msgid ""
#~ "For every request for an object that occurs \"fuzz.time\" before (in the "
#~ "example above, 240 seconds) the object is set to become stale, there is "
#~ "a small chance (fuzz.probability == 0.5%) that the request will trigger "
#~ "a revalidation request to the origin. For objects getting a few requests "
#~ "per second, this would likely not trigger, but then this feature is not "
#~ "necessary anyways since odds are only 1 or a small number of connections "
#~ "would hit origin upon objects going stale. The defaults are a good "
#~ "compromise, for objects getting roughly 4 requests / second or more, "
#~ "it's virtually guaranteed to trigger a revalidate event within the 240s. "
#~ "These configs are also overridable per remap rule or via a plugin, so "
#~ "can be adjusted per request if necessary."
#~ msgstr ""
#~ "新鮮でないとセットされる前に \"fuzz.time\" (上の例では 240 秒) を発生させ"
#~ "るすべてのオブジェクトへのリクエストには、オリジンへの再検証リクエストを"
#~ "引き起こすわずかな可能性 ( fuzz.probability == 0.5% ) があります。秒間 "
#~ "2,3 リクエスト数しかないオブジェクトでは、これはまず引き起こされません。"
#~ "また、オッズがたったの 1 やオブジェクトが新鮮ではなくなり、コネクションが"
#~ "オリジンをヒットする数が少ないとき、この機能は必要ではありません。デフォ"
#~ "ルト値はいい妥協点であり、おおよそ秒間 4 リクエスト以上のオブジェクトに"
#~ "とって、240 秒以内に再検証が引き起こされることが実質的に保証されます。こ"
#~ "れらの設定は remap ルール毎やプラグインによって上書きすることもできるの"
#~ "で、必要であればリクエスト毎に調整することもできます。"

#~ msgid ""
#~ "Note that if the revalidation occurs, the requested object is no longer "
#~ "available to be served from cache.  Subsequent requests for that object "
#~ "will be proxied to the origin."
#~ msgstr ""
#~ "再検証が起きた場合、リクエストされたオブジェクトはもはやキャッシュから配"
#~ "信することはできないことに注意してください。続いて起きるオブジェクトへの"
#~ "リクエストはオリジンサーバーにプロキシーされます。"

#~ msgid ""
#~ "Finally, the fuzz.min_time is there to be able to handle requests with a "
#~ "TTL less than fuzz.time – it allows for different times to evaluate the "
#~ "probability of revalidation for small TTLs and big TTLs. Objects with "
#~ "small TTLs will start \"rolling the revalidation dice\" near the fuzz."
#~ "min_time, while objects with large TTLs would start at fuzz.time. A "
#~ "logarithmic like function between determines the revalidation evaluation "
#~ "start time (which will be between fuzz.min_time and fuzz.time). As the "
#~ "object gets closer to expiring, the window start becomes more likely. By "
#~ "default this setting is not enabled, but should be enabled anytime you "
#~ "have objects with small TTLs. Note that this option predates overridable "
#~ "configurations, so you can achieve something similar with a plugin or "
#~ "remap.config conf_remap.so configs."
#~ msgstr ""
#~ "最後に fuzz.min_time は fuzz.time より短い TTL のリクエストを制御すること"
#~ "を可能にするためにあります - それは小さい TTL と大きい TTL で再検証の確率"
#~ "を評価する時間が異なることを許容します。TTL の小さなオブジェクトは fuzz."
#~ "min_time 付近で \"再検証のサイコロを転がす\" ことを始めます。一方、大き"
#~ "な TTL のオブジェクトは fuzz.time から始めます。対数のような関数が再検証"
#~ "査定を始める時間を決定します。(その値は fuzz.min_time と fuzz.time の間で"
#~ "しょう) 期限切れに近いオブジェクトでは、期間の始まりはより可能性が高くな"
#~ "ります。デフォルトではこの設定は有効化されていません。しかし、TTL の小さ"
#~ "なオブジェクトがある場合、いつでも有効化するべきです。このオプションは設"
#~ "定を上書きする前に起きることに注意してください。よって、プラグインや "
#~ "remap.config conf_remap.so configs のようなものを作ることができます。"

#~ msgid ""
#~ "These configurations are similar to Squid's refresh_stale_hit "
#~ "configuration option."
#~ msgstr ""
#~ "これらの設定は Squid の refresh_stale_hit 設定オプションに似ています。"

#~ msgid ""
#~ "The open read retry configurations attempt to reduce the number of "
#~ "concurrent requests to the origin for a given object. While an object is "
#~ "being fetched from the origin server, subsequent requests would wait "
#~ "open_read_retry_time milliseconds before checking if the object can be "
#~ "served from cache. If the object is still being fetched, the subsequent "
#~ "requests will retry max_open_read_retries times. Thus, subsequent "
#~ "requests may wait a total of (max_open_read_retries x "
#~ "open_read_retry_time) milliseconds before establishing an origin "
#~ "connection of its own. For instance, if they are set to 5 and 10 "
#~ "respectively, connections will wait up to 50ms for a response to come "
#~ "back from origin from a previous request, until this request is allowed "
#~ "through."
#~ msgstr ""
#~ "オープンリードリトライ設定は与えられたオブジェクトに対してオリジンサー"
#~ "バーへの並列リクエストの数を減らすことを試みています。あるオブジェクトが"
#~ "オリジンサーバーからフェッチされている間、次のリクエストはオブジェクトが"
#~ "キャッシュから配信できるかどうかを確認する前に open_read_retry_time ミリ"
#~ "秒待ちます。オブジェクトが依然としてフェッチされている場合、次のリクエス"
#~ "トは max_open_read_retries 回リトライします。すると、次のリクエストはオリ"
#~ "ジンサーバーへのコネクションを自分自身で確立する前に合計で "
#~ "(max_open_read_retries x open_read_retry_time) ミリ秒待ちます。例えばそれ"
#~ "ぞれ 5 や 10 にセットされた場合、このリクエストが許可されるまでコネクショ"
#~ "ンは前回のリクエストがオリジンからレスポンスが帰ってくる間 50ms 待ちま"
#~ "す。"

#~ msgid ""
#~ "These settings are inappropriate when objects are uncacheable. In those "
#~ "cases, requests for an object effectively become serialized. The "
#~ "subsequent requests would await at least open_read_retry_time "
#~ "milliseconds before being proxies to the origin."
#~ msgstr ""
#~ "これらの設定はオブジェクトがキャッシュ不可能な場合、適切ではありません。"
#~ "これらの場合、オブジェクトへのリクエストは実際には直列になります。次のリ"
#~ "クエストはオリジンにプロキシーされる前に少なくとも open_read_retry_time "
#~ "ミリ秒待たされるでしょう。"

#~ msgid ""
#~ "Similarly, this setting should be used in conjunction with Read While "
#~ "Writer for big (those that take longer than (max_open_read_retries x "
#~ "open_read_retry_time) milliseconds to transfer) cacheable objects. "
#~ "Without the read-while-writer settings enabled, while the initial fetch "
#~ "is ongoing, not only would subsequent requests be delayed by the maximum "
#~ "time, but also, those requests would result in another request to the "
#~ "origin server."
#~ msgstr ""
#~ "同様にこの設定は大きな (転送に (max_open_read_retries x "
#~ "open_read_retry_time) ミリ秒以上かかる) キャッシュ可能なオブジェクトの "
#~ "Read While Writer の続発の中では使われるべきです。 read-while-writer 設定"
#~ "を有効化しないと、初回のフェッチが行われている間、次のリクエストが最大限"
#~ "遅れるだけではなく、結果としてオリジンサーバーへの他のリクエストを発生さ"
#~ "せます。"

#~ msgid "The configurations are (with defaults):"
#~ msgstr "設定とそのデフォルト値は"

#~ msgid ""
#~ "CONFIG :ts:cv:`proxy.config.http.cache.max_open_read_retries` ``INT -1``"
#~ msgstr ""
#~ "CONFIG :ts:cv:`proxy.config.http.cache.max_open_read_retries` ``INT -1``"

#~ msgid ""
#~ "CONFIG :ts:cv:`proxy.config.http.cache.open_read_retry_time` ``INT 10``"
#~ msgstr ""
#~ "CONFIG :ts:cv:`proxy.config.http.cache.open_read_retry_time` ``INT 10``"

#~ msgid ""
#~ "The default means that the feature is disabled, and every connection is "
#~ "allowed to go to origin instantly. When enabled, you will try "
#~ "max_open_read_retries times, each with a open_read_retry_time timeout."
#~ msgstr ""
#~ "デフォルトはこの機能が無効化されていて、全てのコネクションはオリジンにす"
#~ "ぐに行くことを許可されていることを意味します。有効化した場合、"
#~ "open_read_retry_time タイムアウト毎に max_open_read_retries 回試すでしょ"
#~ "う。"

#~ msgid ""
#~ "If using :c:func:`TSHttpTxnConfigIntSet`, it must be called no later "
#~ "than `TS_HTTP_READ_RESPONSE_HDR_HOOK`."
#~ msgstr ""
#~ ":c:func:`TSHttpTxnConfigIntSet` を使う場合、"
#~ "`TS_HTTP_READ_RESPONSE_HDR_HOOK` のすぐ後ろで呼ばれなければなりません。"
